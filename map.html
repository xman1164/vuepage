<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>ArcGIS Map with Vue</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

    <style>
        html, body, #viewDiv {
          padding: 0;
          margin: 0;
          height: 100%;
          width: 100%;
          overflow: hidden;
        }

        /* ç¢ºä¿ ArcGIS UI å…ƒç´ ä¸é˜»æ“‹åº•éƒ¨å·¥å…·åˆ— */
        .esri-view .esri-ui-bottom-left,
        .esri-view .esri-ui-bottom-right {
          pointer-events: none;
        }

        .esri-view .esri-ui-bottom-left > *,
        .esri-view .esri-ui-bottom-right > * {
          pointer-events: auto;
        }

        /* === è‡ªè¨‚æ¯”ä¾‹å°º ScaleBar === */
#customScaleBar {
  position: absolute;
  top: 16px;
  left: 16px;
  background: rgba(0,0,0,0.7);
  color: white;
  padding: 6px 12px;
  border-radius: 6px;
  font-size: 14px;
  z-index: 1500;
  pointer-events: none;
}

        /* Vue App Container */
        #app {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          pointer-events: none; /* è®“åœ°åœ–æ“ä½œèƒ½ç©¿é€ */
        }

        /* Floating Action Button */
        .fab {
          position: absolute;
          bottom: 16px;
          right: 16px;
          width: 56px;
          height: 56px;
          background-color: #3f51b5;
          border-radius: 50%;
          box-shadow: 0 3px 5px -1px rgba(0,0,0,.2), 0 6px 10px 0 rgba(0,0,0,.14), 0 1px 18px 0 rgba(0,0,0,.12);
          display: flex;
          align-items: center;
          justify-content: center;
          cursor: pointer;
          pointer-events: auto;
          z-index: 1000;
          color: white;
          font-size: 24px;
        }

        /* Menu Popup */
        .menu-popup {
          position: absolute;
          bottom: 80px;
          right: 16px;
          background-color: white;
          border-radius: 4px;
          box-shadow: 0 2px 4px -1px rgba(0,0,0,.2), 0 4px 5px 0 rgba(0,0,0,.14), 0 1px 10px 0 rgba(0,0,0,.12);
          min-width: 150px;
          pointer-events: auto;
          display: flex;
          flex-direction: column;
          z-index: 999;
          overflow: hidden;
        }

        .menu-item {
          padding: 12px 16px;
          font-size: 16px;
          color: #333;
          cursor: pointer;
          border-bottom: 1px solid #eee;
        }

        .menu-item:last-child {
          border-bottom: none;
        }

        .menu-item:active {
          background-color: #f5f5f5;
        }

        /* Sub Menu (Action Sheet style) */
        .action-sheet {
          position: absolute;
          bottom: 0;
          left: 0;
          width: 100%;
          background-color: white;
          border-top-left-radius: 16px;
          border-top-right-radius: 16px;
          box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
          pointer-events: auto;
          z-index: 1001;
          max-height: 60%;
          display: flex;
          flex-direction: column;
        }

        .sheet-header {
          padding: 16px;
          font-weight: bold;
          text-align: center;
          border-bottom: 1px solid #eee;
          display: flex;
          justify-content: space-between;
          align-items: center;
        }

        .sheet-content {
          overflow-y: auto;
          padding: 8px 0;
        }

        .sheet-item {
          padding: 12px 16px;
          font-size: 16px;
          border-bottom: 1px solid #f0f0f0;
        }

        /* Layer Switch Item */
        .layer-item {
          display: flex;
          justify-content: space-between;
          align-items: center;
          padding: 12px 16px;
          border-bottom: 1px solid #f0f0f0;
        }

        .switch {
          position: relative;
          display: inline-block;
          width: 40px;
          height: 24px;
        }

        .switch input {
          opacity: 0;
          width: 0;
          height: 0;
        }

        .slider {
          position: absolute;
          cursor: pointer;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background-color: #ccc;
          -webkit-transition: .4s;
          transition: .4s;
          border-radius: 24px;
        }

        .slider:before {
          position: absolute;
          content: "";
          height: 18px;
          width: 18px;
          left: 3px;
          bottom: 3px;
          background-color: white;
          -webkit-transition: .4s;
          transition: .4s;
          border-radius: 50%;
        }

        input:checked + .slider {
          background-color: #2196F3;
        }

        input:focus + .slider {
          box-shadow: 0 0 1px #2196F3;
        }

        input:checked + .slider:before {
          -webkit-transform: translateX(16px);
          -ms-transform: translateX(16px);
          transform: translateX(16px);
        }

        /* Mask */
        .mask {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0,0,0,0.5);
          z-index: 1000;
          pointer-events: auto;
        }

        /* Basemap Selection */
        .basemap-selection {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid #eee;
            background-color: #fafafa;
        }

        .basemap-label {
            margin-right: 16px;
            font-weight: bold;
            color: blue;
        }

        .radio-group {
            display: flex;
            gap: 12px;
        }

        .radio-item {
            display: flex;
            align-items: center;
            gap: 4px;
            cursor: pointer;
        }

        /* === æ–°å¢: Snackbar æ¨£å¼ === */
        .snackbar {
          position: absolute;
          top: 16px;
          left: 50%;
          transform: translateX(-50%);
          background-color: rgba(0,0,0,0.9);
          color: white;
          padding: 12px 18px;
          border-radius: 8px;
          font-size: 14px;
          z-index: 2000;
          opacity: 0;
          transition: opacity .25s, transform .25s;
          pointer-events: none;
        }
        .snackbar.show {
          opacity: 1;
          transform: translateX(-50%) translateY(0);
        }

        /* GPS å®šä½æŒ‰éˆ•æ¨£å¼ */
        .locate-button {
          position: absolute;
          bottom: 90px;
          right: 16px;
          width: 48px;
          height: 48px;
          background-color: white;
          border-radius: 50%;
          box-shadow: 0 2px 4px rgba(0,0,0,0.3);
          display: flex;
          align-items: center;
          justify-content: center;
          cursor: pointer;
          pointer-events: auto;
          z-index: 1000;
        }

        .locate-button:active {
          background-color: #f0f0f0;
        }

        .locate-button svg {
          width: 24px;
          height: 24px;
          fill: #3f51b5;
        }

        .locate-button.locating svg {
          fill: #ff9800;
          animation: pulse 1s infinite;
        }

        .locate-button.active svg {
          fill: #4CAF50;
        }

        @keyframes pulse {
          0%, 100% { opacity: 1; }
          50% { opacity: 0.5; }
        }

        /* æŸ¥è©¢å°è©±æ¡†æ¨£å¼ */
        .query-dialog {
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background-color: white;
          border-radius: 8px;
          box-shadow: 0 8px 16px rgba(0,0,0,0.3);
          pointer-events: auto;
          z-index: 1002;
          width: 90%;
          max-width: 400px;
        }

        .dialog-header {
          padding: 16px 20px;
          border-bottom: 1px solid #e0e0e0;
          font-size: 18px;
          font-weight: bold;
          color: #333;
        }

        .dialog-content {
          padding: 20px;
        }

        .input-field {
          margin-top: 16px;
        }

        .input-label {
          display: block;
          font-size: 12px;
          color: #666;
          margin-bottom: 4px;
        }

        .input-box {
          width: 100%;
          padding: 10px 12px;
          border: 1px solid #ccc;
          border-radius: 4px;
          font-size: 16px;
          box-sizing: border-box;
        }

        .input-box:focus {
          outline: none;
          border-color: #3f51b5;
        }

        .dialog-actions {
          padding: 12px 20px;
          border-top: 1px solid #e0e0e0;
          display: flex;
          justify-content: flex-end;
          gap: 8px;
        }

        .dialog-button {
          padding: 8px 16px;
          border: none;
          border-radius: 4px;
          font-size: 14px;
          cursor: pointer;
          font-weight: 500;
        }

        .button-cancel {
          background-color: #f5f5f5;
          color: #666;
        }

        .button-confirm {
          background-color: #3f51b5;
          color: white;
        }

        .button-cancel:active {
          background-color: #e0e0e0;
        }

        .button-confirm:active {
          background-color: #303f9f;
        }

        /* çµæœåˆ—è¡¨å°è©±æ¡† */
        .result-list {
          max-height: 300px;
          overflow-y: auto;
        }

        .result-item {
          padding: 12px 20px;
          border-bottom: 1px solid #f0f0f0;
          cursor: pointer;
        }

        .result-item:hover {
          background-color: #f5f5f5;
        }

        .result-item:active {
          background-color: #e0e0e0;
        }

        .result-title {
          font-weight: bold;
          color: #333;
          margin-bottom: 4px;
        }

        .result-detail {
          font-size: 12px;
          color: #666;
        }

        /* === ç¹ªåœ–å·¥å…·åˆ— === */
        .draw-toolbar {
          position: absolute;
          bottom: 80px;
          left: 50%;
          transform: translateX(-50%);
          background-color: white;
          border-radius: 28px;
          box-shadow: 0 4px 6px rgba(0,0,0,0.1);
          padding: 8px;
          pointer-events: auto;
          z-index: 1001;
          display: flex;
          align-items: center;
          gap: 4px;
          overflow-x: auto;
          overflow-y: hidden;
          max-width: 90vw;
          -webkit-overflow-scrolling: touch;
        }

        .draw-toolbar::-webkit-scrollbar {
          display: none;
        }

        .draw-tool-btn {
          width: 48px;
          height: 48px;
          border-radius: 50%;
          border: none;
          background-color: transparent;
          cursor: pointer;
          display: flex;
          align-items: center;
          justify-content: center;
          flex-shrink: 0;
          transition: background-color 0.2s;
        }

        .draw-tool-btn:active {
          background-color: #e0e0e0;
        }

        .draw-tool-btn.active {
          background-color: #3f51b5;
          color: white;
        }

        .draw-tool-btn .material-icons {
          font-size: 24px;
          color: inherit;
        }

        .draw-tool-btn:not(.active) .material-icons {
          color: #666;
        }

        /* æ¸¬é‡çµæœé¡¯ç¤º */
        .measurement-tooltip {
          position: absolute;
          background-color: rgba(0,0,0,0.8);
          color: white;
          padding: 6px 12px;
          border-radius: 4px;
          font-size: 14px;
          pointer-events: none;
          z-index: 2000;
          white-space: nowrap;
        }

        /* === æ‹ç…§å°è©±æ¡† === */
        .photo-dialog-overlay {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.5);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 2000;
          pointer-events: auto;
        }

        .photo-dialog {
          background-color: white;
          border-radius: 8px;
          padding: 20px;
          width: 90%;
          max-width: 400px;
          box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .photo-dialog-title {
          font-size: 18px;
          font-weight: bold;
          margin-top: 16px;
          color: #333;
        }

        .photo-dialog-field {
          margin-top: 16px;
        }

        .photo-dialog-label {
          display: block;
          font-size: 14px;
          color: #666;
          margin-bottom: 6px;
        }

        .photo-dialog-input {
          width: 100%;
          padding: 10px;
          border: 1px solid #ddd;
          border-radius: 4px;
          font-size: 14px;
          box-sizing: border-box;
        }

        .photo-dialog-select {
          width: 100%;
          padding: 10px;
          border: 1px solid #ddd;
          border-radius: 4px;
          font-size: 14px;
          box-sizing: border-box;
          background-color: white;
        }

        .photo-dialog-buttons {
          display: flex;
          gap: 10px;
          margin-top: 20px;
        }

        .photo-dialog-button {
          flex: 1;
          padding: 12px;
          border: none;
          border-radius: 4px;
          font-size: 14px;
          cursor: pointer;
          transition: background-color 0.2s;
        }

        .photo-dialog-button.primary {
          background-color: #3f51b5;
          color: white;
        }

        .photo-dialog-button.primary:active {
          background-color: #303f9f;
        }

        .photo-dialog-button.secondary {
          background-color: #f5f5f5;
          color: #333;
        }

        .photo-dialog-button.secondary:active {
          background-color: #e0e0e0;
        }

        /* === å·¡å‹˜æ¨™è¨»å·¥å…·åˆ— === */
        .annotation-toolbar {
          position: fixed;
          bottom: 0;
          left: 50%;
          transform: translateX(-50%);
          background-color: rgba(255, 255, 255, 0.98);
          border-radius: 20px 20px 0 0;
          box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.2);
          padding: 8px 12px;
          display: flex;
          gap: 6px;
          max-width: 95vw;
          overflow-x: auto;
          overflow-y: hidden;
          z-index: 9999;
          -webkit-overflow-scrolling: touch;
          pointer-events: auto;
        }

        .annotation-toolbar::-webkit-scrollbar {
          display: none;
        }

        .annotation-tool-btn {
          width: 48px;
          height: 48px;
          border-radius: 50%;
          border: none;
          background-color: #f5f5f5;
          color: #333;
          cursor: pointer;
          transition: all 0.2s;
          flex-shrink: 0;
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 24px;
          pointer-events: auto;
          touch-action: manipulation;
        }

        .annotation-tool-btn:active {
          background-color: #e0e0e0;
          transform: scale(0.95);
        }

        .annotation-tool-btn.active {
          background-color: #3f51b5;
          color: white;
        }

        /* æ–‡å­—è¼¸å…¥å°è©±æ¡† */
        .text-input-dialog-overlay {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.5);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 10000;
          pointer-events: auto;
        }

        .text-input-dialog {
          background-color: white;
          border-radius: 8px;
          padding: 20px;
          width: 90%;
          max-width: 400px;
          box-shadow: 0 4px 12px rgba(0,0,0,0.3);
          pointer-events: auto;
          touch-action: auto;
        }

        .text-input-dialog-title {
          font-size: 18px;
          font-weight: bold;
          margin-top: 16px;
          color: #333;
        }

        .text-input-dialog-input {
          width: 100%;
          padding: 12px;
          border: 1px solid #ddd;
          border-radius: 4px;
          font-size: 16px;
          box-sizing: border-box;
          margin-top: 16px;
          pointer-events: auto;
          touch-action: auto;
        }

        .text-input-dialog-buttons {
          display: flex;
          gap: 10px;
          pointer-events: auto;
        }

        .text-input-dialog-button {
          flex: 1;
          padding: 12px;
          border: none;
          border-radius: 4px;
          font-size: 14px;
          cursor: pointer;
          pointer-events: auto;
          touch-action: manipulation;
        }

        .text-input-dialog-button.primary {
          background-color: #3f51b5;
          color: white;
        }

        .text-input-dialog-button.secondary {
          background-color: #f5f5f5;
          color: #333;
        }

        /* === å·¡å‹˜é¸æ“‡åˆ—è¡¨ === */
        .inspection-list-dialog-overlay {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.5);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 10000;
          pointer-events: auto;
        }

        .inspection-list-dialog {
          background-color: white;
          border-radius: 8px;
          width: 90%;
          max-width: 500px;
          max-height: 70vh;
          display: flex;
          flex-direction: column;
          box-shadow: 0 4px 12px rgba(0,0,0,0.3);
          pointer-events: auto;
        }

        .inspection-list-header {
          padding: 20px;
          border-bottom: 1px solid #e0e0e0;
          display: flex;
          justify-content: space-between;
          align-items: center;
        }

        .inspection-list-title {
          font-size: 18px;
          font-weight: bold;
          color: #333;
        }

        .inspection-list-close {
          width: 32px;
          height: 32px;
          border: none;
          background: none;
          color: #666;
          font-size: 24px;
          cursor: pointer;
          display: flex;
          align-items: center;
          justify-content: center;
        }

        .inspection-list-body {
          overflow-y: auto;
          flex: 1;
        }

        .inspection-list-item {
          padding: 16px 20px;
          border-bottom: 1px solid #f0f0f0;
          cursor: pointer;
          transition: background-color 0.2s;
        }

        .inspection-list-item:hover {
          background-color: #f5f5f5;
        }

        .inspection-list-item:active {
          background-color: #e0e0e0;
        }

        .inspection-list-item-text {
          font-size: 16px;
          color: #333;
        }

        .inspection-list-empty {
          padding: 40px 20px;
          text-align: center;
          color: #999;
        }

        /* === è»Œè·¡å·¡å‹˜ === */
        /* åœæ­¢æŒ‰éˆ•ï¼ˆå·¦ä¸Šè§’æµ®å‹•ï¼‰ */
        .track-stop-btn {
          position: fixed;
          top: 20px;
          left: 20px;
          width: 80px;
          height: 80px;
          border-radius: 50%;
          background-color: #f44336;
          color: white;
          border: 4px solid white;
          box-shadow: 0 4px 12px rgba(0,0,0,0.4);
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          cursor: pointer;
          z-index: 9999;
          pointer-events: auto;
          font-size: 14px;
          font-weight: bold;
        }

        .track-stop-btn:active {
          background-color: #d32f2f;
          transform: scale(0.95);
        }

        .track-stop-btn .material-icons {
          font-size: 36px;
          margin-bottom: 4px;
        }

        /* è»Œè·¡ç‹€æ…‹æç¤ºï¼ˆè·Ÿéš¨åœæ­¢æŒ‰éˆ•ï¼‰ */
        .track-status-label {
          position: fixed;
          top: 24px;
          left: 110px;
          background-color: rgba(0, 0, 0, 0.8);
          color: white;
          padding: 12px 16px;
          border-radius: 8px;
          font-size: 14px;
          z-index: 9998;
          pointer-events: none;
          box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        /* è»Œè·¡ç¢ºèªå°è©±æ¡† */
        .track-confirm-dialog-overlay {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.6);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 10000;
          pointer-events: auto;
        }

        .track-confirm-dialog {
          background-color: white;
          border-radius: 12px;
          width: 90%;
          max-width: 600px;
          max-height: 85vh;
          display: flex;
          flex-direction: column;
          box-shadow: 0 8px 24px rgba(0,0,0,0.4);
          pointer-events: auto;
        }

        .track-confirm-header {
          padding: 20px;
          border-bottom: 2px solid #e0e0e0;
          text-align: center;
        }

        .track-confirm-title {
          font-size: 20px;
          font-weight: bold;
          color: #333;
          margin-top: 16px;
        }

        .track-device-counts {
          display: flex;
          justify-content: space-around;
          flex-wrap: wrap;
          gap: 12px;
          margin-bottom: 12px;
        }

        .track-device-count-item {
          font-size: 14px;
          color: #666;
        }

        .track-device-count-item strong {
          color: #2196F3;
          font-size: 16px;
        }

        .track-device-list-divider {
          height: 1px;
          background-color: #ddd;
          margin: 12px 0;
        }

        .track-confirm-body {
          overflow-y: auto;
          flex: 1;
          padding: 20px;
        }

        .track-device-list {
          font-size: 14px;
          color: #333;
          line-height: 1.6;
          word-wrap: break-word;
          margin-top: 16px;
        }

        .track-screenshot-preview {
          width: 100%;
          border-radius: 8px;
          box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .track-confirm-footer {
          padding: 16px 20px;
          border-top: 1px solid #e0e0e0;
          display: flex;
          gap: 12px;
        }

        .track-confirm-btn {
          flex: 1;
          padding: 14px;
          border: none;
          border-radius: 8px;
          font-size: 16px;
          font-weight: bold;
          cursor: pointer;
          transition: all 0.2s;
        }

        .track-confirm-btn.cancel {
          background-color: #f5f5f5;
          color: #666;
        }

        .track-confirm-btn.cancel:active {
          background-color: #e0e0e0;
        }

        .track-confirm-btn.confirm {
          background-color: #4CAF50;
          color: white;
        }

        .track-confirm-btn.confirm:active {
          background-color: #45a049;
        }


        /* ===== è»Œè·¡å·¡å‹˜æ¨£å¼ ===== */

        /* åœæ­¢æŒ‰éˆ•ï¼ˆå·¦ä¸Šè§’æµ®å‹•ï¼‰ */
        .track-stop-button {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 99999;
            background-color: #f44336;
            color: white;
            border: none;
            border-radius: 50%;
            width: 80px;
            height: 80px;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            cursor: pointer;
            pointer-events: auto;
            -webkit-tap-highlight-color: transparent;
        }

        .track-stop-button:active {
            transform: scale(0.95);
            background-color: #d32f2f;
        }
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            line-height: 1.2;
        }

        .track-stop-button:active {
            transform: scale(0.95);
        }

        /* è¨˜éŒ„ç‹€æ…‹æ¨™ç±¤ï¼ˆè·Ÿéš¨åœæ­¢æŒ‰éˆ•ï¼‰ */
        .track-status-label {
            position: fixed;
            top: 25px;
            left: 110px;
            z-index: 10000;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        /* ç¢ºèªå°è©±æ¡† */
        .track-confirm-dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            pointer-events: auto;
        }

        .track-confirm-dialog {
            background-color: white;
            border-radius: 12px;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
        }

        .track-confirm-header {
            padding: 20px;
            border-bottom: 1px solid #e0e0e0;
            font-size: 18px;
            font-weight: bold;
        }

        .track-confirm-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }

        .device-counts {
            margin-top: 16px;
            padding: 12px;
            background-color: #f5f5f5;
            border-radius: 8px;
        }

        .device-counts-item {
            margin: 4px 0;
            font-size: 14px;
        }

        .device-list {
            margin-top: 16px;
            padding: 12px;
            background-color: #fff3e0;
            border-radius: 8px;
            font-size: 13px;
            line-height: 1.6;
            word-break: break-all;
        }

        .track-screenshot {
            width: 100%;
            margin-top: 16px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .track-confirm-actions {
            padding: 20px;
            border-top: 1px solid #e0e0e0;
            display: flex;
            gap: 12px;
        }

        .track-confirm-actions button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
        }

        .track-cancel-btn {
            background-color: #9e9e9e;
            color: white;
        }

        .track-confirm-btn {
            background-color: #4caf50;
            color: white;
        }

        /* ===== è·¨è¶Šçºœç·šæ¨£å¼ ===== */

        /* é›»æ¡¿æ¸…å–®å°è©±æ¡† */
        .pole-list-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 99999;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }

        .pole-list-dialog {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 400px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
            pointer-events: auto;
        }

        .pole-list-header {
            padding: 20px;
            border-bottom: 1px solid #e0e0e0;
            font-size: 18px;
            font-weight: bold;
        }

        .pole-list-body {
            padding: 10px;
            overflow-y: auto;
            flex: 1;
        }

        .pole-list-item {
            padding: 15px;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
            transition: background-color 0.2s;
            pointer-events: auto;
            user-select: none;
        }

        .pole-list-item:hover {
            background-color: #f5f5f5;
        }

        .pole-list-item:active {
            background-color: #e0e0e0;
        }

        .pole-name {
            font-size: 16px;
            font-weight: 500;
            color: #333;
            margin-bottom: 4px;
        }

        .pole-distance {
            font-size: 14px;
            color: #666;
        }

        .pole-list-footer {
            padding: 15px;
            border-top: 1px solid #e0e0e0;
            display: flex;
            justify-content: flex-end;
        }

        .pole-list-footer button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
        }

        /* è·¨è¶Šçºœç·šè¡¨å–®å°è©±æ¡† */
        .cable-form-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 99999;
            pointer-events: auto;
        }

        .cable-form-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: white;
            display: flex;
            flex-direction: column;
        }

        .cable-form-header {
            padding: 15px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
            background: #3f51b5;
            color: white;
        }

        .cable-form-header button {
            background: transparent;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            margin-right: 10px;
        }

        .cable-form-header h3 {
            margin: 0;
            font-size: 18px;
            font-weight: 500;
        }

        .cable-form-body {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            -webkit-overflow-scrolling: touch;
        }

        .form-section {
            margin-bottom: 20px;
        }

        .form-section label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #333;
            font-size: 14px;
        }

        .form-section input[type="text"],
        .form-section input[type="number"],
        .form-section input[type="date"],
        .form-section select,
        .form-section textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 16px;
            box-sizing: border-box;
        }

        .form-section textarea {
            min-height: 80px;
            resize: vertical;
        }

        .form-section input[readonly] {
            background-color: #f5f5f5;
            color: #666;
        }

        .form-row {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .form-row > div {
            flex: 1;
        }

        .form-row .select-wrapper {
            flex: 0 0 auto;
        }

        /* ç…§ç‰‡å€åŸŸ */
        .photo-section {
            margin-top: 20px;
        }

        .photo-buttons {
            display: flex;
            gap: 10px;
        }

        .photo-buttons button {
            flex: 1;
            padding: 12px;
            background: #007AFF;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
        }

        .photo-buttons button:active {
            background: #0056b3;
        }

        .photo-preview {
            position: relative;
            display: inline-block;
        }

        .photo-preview img {
            max-width: 200px;
            max-height: 200px;
            border-radius: 8px;
            border: 1px solid #ddd;
        }

        .remove-photo-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(255, 0, 0, 0.8);
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* é™„æ›çºœç·šæ¸…å–® */
        .pole-lines-section {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px solid #e0e0e0;
        }

        .pole-lines-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .pole-lines-header h4 {
            margin: 0;
            font-size: 16px;
        }

        .add-line-btn {
            padding: 8px 16px;
            background: #4caf50;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
        }

        .pole-line-item {
            background: #f5f5f5;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            position: relative;
        }

        .pole-line-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .pole-line-number {
            font-weight: 500;
            font-size: 15px;
        }

        .remove-line-btn {
            background: #f44336;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            font-size: 12px;
            cursor: pointer;
        }

        .pole-line-fields {
            display: grid;
            gap: 10px;
        }

        .checkbox-field {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .checkbox-field input[type="checkbox"] {
            width: 20px;
            height: 20px;
        }

        /* è¡¨å–®åº•éƒ¨æŒ‰éˆ• */
        .cable-form-footer {
            padding: 15px;
            border-top: 1px solid #e0e0e0;
            display: flex;
            gap: 10px;
            background: white;
        }

        .cable-form-footer button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
        }

        .cable-cancel-btn {
            background-color: #9e9e9e;
            color: white;
        }

        .cable-submit-btn {
            background-color: #4caf50;
            color: white;
        }
    </style>
    <link rel="stylesheet" href="https://js.arcgis.com/4.28/esri/themes/light/main.css">
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
    <script src="https://js.arcgis.com/4.28/"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="modules/inspection.js"></script>
    <script src="modules/track-inspection.js"></script>
    <script src="modules/cable-crossing.js"></script>
    <script>console.log('=== æº–å‚™è¼‰å…¥æ–½å·¥ä½ç½®æ¨¡çµ„ ===');</script>
    <script src="modules/taipei-construction.js"></script>
    <script>console.log('å°åŒ—å¸‚æ¨¡çµ„è¼‰å…¥å®Œæˆ, TaipeiConstructionModule:', typeof window.TaipeiConstructionModule);</script>
    <script src="modules/newtaipei-construction.js"></script>
    <script src="modules/taoyuan-construction.js"></script>
    <script>console.log('=== æ‰€æœ‰æ–½å·¥ä½ç½®æ¨¡çµ„è¼‰å…¥å®Œæˆ ===');</script>

    <script>
        // â­ Firebase åˆå§‹åŒ–å°±æ”¾é€™è£¡ â­

        var firebaseConfig = {
          apiKey: "AIzaSyCuJBueZtQheTtF2I7C0_VgGtnlRzdenMI",
    authDomain: "fcmdemo-625a7.firebaseapp.com",
    databaseURL: "https://fcmdemo-625a7-default-rtdb.firebaseio.com",
    projectId: "fcmdemo-625a7",
    storageBucket: "fcmdemo-625a7.firebasestorage.app",
    messagingSenderId: "304723346765",
    appId: "1:304723346765:web:e291dca6e3be82de0ae304"
        };

        firebase.initializeApp(firebaseConfig);
        var db = firebase.database();

        // â­ App ç‰ˆæœ¬æª¢æŸ¥åŠŸèƒ½
        window.checkAppVersion = function() {
            console.log("========================================");
            console.log("ğŸ” é–‹å§‹æª¢æŸ¥ App ç‰ˆæœ¬");
            console.log("========================================");

            try {
                if (!window.Android || !window.Android.getVersionCode || !window.Android.getAppVersion) {
                    console.warn("âš ï¸ Android ä»‹é¢ä¸å­˜åœ¨ï¼Œè·³éç‰ˆæœ¬æª¢æŸ¥");
                    return;
                }

                var currentVersionCode = parseInt(window.Android.getVersionCode());
                var currentVersionName = window.Android.getAppVersion();

                console.log("ğŸ“± ç•¶å‰ç‰ˆæœ¬:", currentVersionName, "(code:", currentVersionCode + ")");

                // ä½¿ç”¨ firebase.database() è€Œé db è®Šæ•¸
                firebase.database().ref("app_version").once("value")
                    .then(function(snapshot) {
                        if (!snapshot.exists()) {
                            console.warn("âš ï¸ Firebase ç„¡ç‰ˆæœ¬è³‡è¨Š");
                            return;
                        }

                        var data = snapshot.val();
                        var latestVersionCode = data.version_code || 0;
                        var latestVersionName = data.version_name || "";
                        var downloadUrl = data.download_url || "";
                        var releaseNotes = data.release_notes || "éŒ¯èª¤ä¿®æ­£èˆ‡æ•ˆèƒ½æ”¹å–„";
                        var forceUpdate = data.force_update || false;

                        console.log("â˜ï¸ æœ€æ–°ç‰ˆæœ¬:", latestVersionName, "(code:", latestVersionCode + ")");
                        console.log("ğŸ“ æ›´æ–°èªªæ˜:", releaseNotes);
                        console.log("âš ï¸ å¼·åˆ¶æ›´æ–°:", forceUpdate);

                        if (latestVersionCode > currentVersionCode) {
                            console.log("âœ¨ ç™¼ç¾æ–°ç‰ˆæœ¬ï¼");
                            showUpdateDialog(latestVersionName, releaseNotes, downloadUrl, forceUpdate);
                        } else {
                            console.log("âœ“ å·²æ˜¯æœ€æ–°ç‰ˆæœ¬");
                        }

                        console.log("========================================");
                    })
                    .catch(function(error) {
                        console.error("âŒ ç‰ˆæœ¬æª¢æŸ¥å¤±æ•—:", error);
                    });

            } catch (e) {
                console.error("âŒ ç‰ˆæœ¬æª¢æŸ¥ç•°å¸¸:", e);
            }
        };

        function showUpdateDialog(versionName, releaseNotes, downloadUrl, forceUpdate) {
            var mask = document.createElement("div");
            mask.id = "updateDialogMask";
            mask.style.cssText = "position:fixed;left:0;top:0;width:100vw;height:100vh;background:rgba(0,0,0,0.6);display:flex;justify-content:center;align-items:center;z-index:99999;";

            var dialog = document.createElement("div");
            dialog.style.cssText = "width:340px;background:#fff;border-radius:12px;padding:24px;box-shadow:0 8px 24px rgba(0,0,0,0.3);font-family:Arial,sans-serif;";

            var title = document.createElement("div");
            title.style.cssText = "font-size:20px;font-weight:bold;color:#333;margin-bottom:16px;text-align:center;";
            title.textContent = "ç™¼ç¾æ–°ç‰ˆæœ¬ " + versionName;

            var content = document.createElement("div");
            content.style.cssText = "font-size:15px;color:#666;line-height:1.6;margin-bottom:24px;white-space:pre-line;";
            content.textContent = "æ›´æ–°å…§å®¹ï¼š\n" + releaseNotes;

            var buttons = document.createElement("div");
            buttons.style.cssText = "display:flex;gap:12px;";

            var updateBtn = document.createElement("button");
            updateBtn.textContent = "ç«‹å³æ›´æ–°";
            updateBtn.style.cssText = "flex:1;padding:12px;background:#007aff;color:white;border:none;border-radius:8px;font-size:16px;font-weight:bold;cursor:pointer;";
            updateBtn.onclick = function() {
                if (downloadUrl) {
                    console.log("ğŸ”— é–‹å•Ÿä¸‹è¼‰é€£çµ:", downloadUrl);
                    // ä½¿ç”¨ Android æ–¹æ³•é–‹å•Ÿå¤–éƒ¨ç€è¦½å™¨
                    if (window.Android && window.Android.openExternalBrowser) {
                        window.Android.openExternalBrowser(downloadUrl);
                    } else {
                        // å‚™ç”¨æ–¹æ¡ˆ
                        window.open(downloadUrl, "_blank");
                    }
                } else {
                    alert("ä¸‹è¼‰é€£çµç„¡æ•ˆ");
                }
            };

            if (!forceUpdate) {
                var laterBtn = document.createElement("button");
                laterBtn.textContent = "ä¸‹æ¬¡å†èªª";
                laterBtn.style.cssText = "flex:1;padding:12px;background:#f0f0f0;color:#333;border:none;border-radius:8px;font-size:16px;cursor:pointer;";
                laterBtn.onclick = function() {
                    document.body.removeChild(mask);
                };
                buttons.appendChild(laterBtn);
            }

            buttons.appendChild(updateBtn);

            dialog.appendChild(title);
            dialog.appendChild(content);
            dialog.appendChild(buttons);
            mask.appendChild(dialog);

            if (forceUpdate) {
                mask.onclick = function(e) {
                    if (e.target === mask) {
                        alert("æ­¤ç‰ˆæœ¬å¿…é ˆæ›´æ–°æ‰èƒ½ç¹¼çºŒä½¿ç”¨");
                    }
                };
            } else {
                mask.onclick = function(e) {
                    if (e.target === mask) {
                        document.body.removeChild(mask);
                    }
                };
            }

            document.body.appendChild(mask);
        }
    </script>
</head>
<body>
<div id="viewDiv"></div>

<div id="app">
    <!-- Mask for modal -->
    <div class="mask" v-if="currentSubMenu || isLayerDialogVisible || isQueryDialogVisible || isResultListVisible || isCoordinateDialogVisible || isNavigationDialogVisible || isDistrictListVisible" @click="closeAll"></div>

    <!-- GPS å®šä½æŒ‰éˆ• -->
    <div :class="['locate-button', isLocating ? 'locating' : '', isLocationActive ? 'active' : '']" @click="triggerLocate">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm8.94 3c-.46-4.17-3.77-7.48-7.94-7.94V1h-2v2.06C6.83 3.52 3.52 6.83 3.06 11H1v2h2.06c.46 4.17 3.77 7.48 7.94 7.94V23h2v-2.06c4.17-.46 7.48-3.77 7.94-7.94H23v-2h-2.06zM12 19c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z"/>
        </svg>
    </div>

    <!-- Floating Action Button -->
    <div class="fab" @click="toggleMainMenu">
        <span>+</span>
    </div>

    <!-- Main Menu -->
    <div class="menu-popup" v-if="isMainMenuVisible">
        <div class="menu-item" @click="openLayerDialog">åœ–å±¤</div>
        <div class="menu-item" @click="openSubMenu('æŸ¥è©¢')">æŸ¥è©¢</div>
        <div class="menu-item" @click="openSubMenu('å°èˆª')">å°èˆª</div>
        <div class="menu-item" @click="openSubMenu('å·¡å‹˜')">å·¡å‹˜</div>
        <div class="menu-item" @click="openSubMenu('å…¶ä»–')">å…¶ä»–</div>
    </div>

    <!-- Sub Menu (Generic Action Sheet) -->
    <div class="action-sheet" v-if="currentSubMenu">
        <div class="sheet-header">
            <span>{{ currentSubMenu }}</span>
            <span style="color: blue; cursor: pointer;" @click="closeAll">é—œé–‰</span>
        </div>
        <div class="sheet-content">
            <div class="sheet-item" v-for="item in subMenuItems[currentSubMenu]" :key="item" @click="onSubMenuItemClick(item)">
                {{ item }}
            </div>
        </div>
    </div>

    <!-- Layer Dialog -->
    <div class="action-sheet" v-if="isLayerDialogVisible">
        <div class="sheet-header">
            <span>åœ–å±¤é¸æ“‡</span>
            <span style="color: blue; cursor: pointer;" @click="closeAll">é—œé–‰</span>
        </div>

        <!-- Basemap Selector -->
        <div class="basemap-selection">
            <div class="basemap-label">åº•åœ–é¸æ“‡</div>
            <div class="radio-group">
                <label class="radio-item">
                    <input type="radio" value="CHTGIS" v-model="selectedBasemap" @change="changeBasemap">
                    CHTGIS
                </label>
                <label class="radio-item">
                    <input type="radio" value="NLSC" v-model="selectedBasemap" @change="changeBasemap">
                    åœ‹åœŸæ¸¬ç¹ª
                </label>
            </div>
        </div>

        <div class="sheet-content">
            <div class="layer-item" v-for="layer in layerList" :key="layer.name">
                <span>{{ layer.name }}</span>
                <label class="switch">
                    <input type="checkbox" v-model="layer.isEnabled" @change="toggleMapLayer(layer)">
                    <span class="slider"></span>
                </label>
            </div>
        </div>
    </div>

    <!-- é€šç”¨æŸ¥è©¢å°è©±æ¡† -->
    <div class="query-dialog" v-if="isQueryDialogVisible">
        <div class="dialog-header">{{ currentQueryType }}</div>
        <div class="dialog-content">
            <div class="input-field" v-for="field in queryConfigs[currentQueryType]?.fields" :key="field.key">
                <label class="input-label">{{ field.label }}</label>
                <input
                        type="text"
                        class="input-box"
                        v-model="queryParams[field.key]"
                        @input="field.uppercase ? upperCaseInput(field.key) : null"
                        :placeholder="field.placeholder">
            </div>
        </div>
        <div class="dialog-actions">
            <button class="dialog-button button-cancel" @click="closeQueryDialog">å–æ¶ˆ</button>
            <button class="dialog-button button-confirm" @click="executeQuery">ç¢ºå®š</button>
        </div>
    </div>

    <!-- æŸ¥è©¢çµæœåˆ—è¡¨å°è©±æ¡† -->
    <div class="query-dialog" v-if="isResultListVisible && queryResults.length > 0">
        <div class="dialog-header">æŸ¥è©¢çµæœ ({{ queryResults.length }} ç­†)</div>
        <div class="result-list">
            <div class="result-item" v-for="(result, index) in queryResults" :key="index" @click="zoomToResult(result)">
                <template v-if="queryConfigs[currentQueryType]">
                    <div class="result-title">{{ queryConfigs[currentQueryType].displayFields(result.attributes).title }}</div>
                    <div class="result-detail">{{ queryConfigs[currentQueryType].displayFields(result.attributes).subtitle }}</div>
                </template>
                <template v-else>
                    <div class="result-title">çµæœ {{ index + 1 }}</div>
                    <div class="result-detail">é»æ“ŠæŸ¥çœ‹</div>
                </template>
            </div>
        </div>
        <div class="dialog-actions">
            <button class="dialog-button button-cancel" @click="closeResultList">é—œé–‰</button>
        </div>
    </div>

    <!-- åº§æ¨™æŸ¥è©¢å°è©±æ¡† -->
    <div class="query-dialog" v-if="isCoordinateDialogVisible">
        <div class="dialog-header">åº§æ¨™æŸ¥è©¢</div>
        <div class="dialog-content">
            <div class="basemap-selection" style="margin-top: 16px; padding: 12px; background-color: #f5f5f5; border-radius: 4px;">
                <div class="basemap-label" style="margin-right: 12px;">åº§æ¨™ç³»çµ±</div>
                <div class="radio-group">
                    <label class="radio-item">
                        <input type="radio" value="TWD97" v-model="coordinateParams.coordSystem">
                        TWD97 (X, Y)
                    </label>
                    <label class="radio-item">
                        <input type="radio" value="WGS84" v-model="coordinateParams.coordSystem">
                        WGS84 (ç¶“åº¦, ç·¯åº¦)
                    </label>
                </div>
            </div>
            <div class="input-field">
                <label class="input-label">{{ coordinateParams.coordSystem === 'TWD97' ? 'X åº§æ¨™' : 'ç¶“åº¦ (Longitude)' }}</label>
                <input type="number" step="any" class="input-box" v-model="coordinateParams.x" :placeholder="coordinateParams.coordSystem === 'TWD97' ? 'ä¾‹å¦‚: 302345.67' : 'ä¾‹å¦‚: 121.5170'">
            </div>
            <div class="input-field">
                <label class="input-label">{{ coordinateParams.coordSystem === 'TWD97' ? 'Y åº§æ¨™' : 'ç·¯åº¦ (Latitude)' }}</label>
                <input type="number" step="any" class="input-box" v-model="coordinateParams.y" :placeholder="coordinateParams.coordSystem === 'TWD97' ? 'ä¾‹å¦‚: 2765432.10' : 'ä¾‹å¦‚: 25.0478'">
            </div>
        </div>
        <div class="dialog-actions">
            <button class="dialog-button button-cancel" @click="closeCoordinateDialog">å–æ¶ˆ</button>
            <button class="dialog-button button-confirm" @click="executeCoordinateQuery">å®šä½</button>
        </div>
    </div>

    <!-- å°èˆªç›®æ¨™å°è©±æ¡† -->
    <div class="query-dialog" v-if="isNavigationDialogVisible">
        <div class="dialog-header">å°èˆªç›®æ¨™</div>
        <div class="result-list">
            <div class="result-item" v-for="(target, index) in navigationTargets" :key="index" @click="navigateToTarget(target)">
                <div class="result-title">å°èˆªåˆ° => {{ target.name }}</div>
                <div class="result-detail">ç¶“åº¦: {{ target.longitude.toFixed(6) }}, ç·¯åº¦: {{ target.latitude.toFixed(6) }}</div>
            </div>
        </div>
        <div class="dialog-actions">
            <button class="dialog-button button-cancel" @click="closeNavigationDialog">é—œé–‰</button>
        </div>
    </div>

    <!-- è¡Œæ”¿å€æ¸…å–®å°è©±æ¡† -->
    <div class="query-dialog" v-if="isDistrictListVisible">
        <div class="dialog-header">
            <span class="material-icons">location_city</span>
            <span>é¸æ“‡è¡Œæ”¿å€</span>
            <button class="dialog-close" @click="isDistrictListVisible = false">
                <span class="material-icons">close</span>
            </button>
        </div>
        <div class="dialog-body" style="max-height: 400px; overflow-y: auto;">
            <div
                    v-for="district in districtList"
                    :key="district"
                    class="result-item"
                    @click="selectConstructionDistrict(district)"
                    style="cursor: pointer; padding: 12px; border-bottom: 1px solid #e0e0e0;"
            >
                <div style="font-weight: 500;">{{ district }}</div>
            </div>
        </div>
    </div>

    <!-- === ç¹ªåœ–å·¥å…·åˆ— === -->
    <div v-if="isDrawToolbarVisible" class="draw-toolbar">
        <button class="draw-tool-btn" :class="{active: currentDrawTool === 'point'}" @click="selectDrawTool('point')" title="ç•«é»">
            <span class="material-icons">place</span>
        </button>
        <button class="draw-tool-btn" :class="{active: currentDrawTool === 'polyline'}" @click="selectDrawTool('polyline')" title="ç•«ç·š">
            <span class="material-icons">timeline</span>
        </button>
        <button class="draw-tool-btn" :class="{active: currentDrawTool === 'polygon'}" @click="selectDrawTool('polygon')" title="ç•«é¢">
            <span class="material-icons">pentagon</span>
        </button>
        <button class="draw-tool-btn" @click="undoDrawing" title="å›ä¸Šä¸€æ­¥">
            <span class="material-icons">undo</span>
        </button>
        <button class="draw-tool-btn" @click="redoDrawing" title="ä¸‹ä¸€æ­¥">
            <span class="material-icons">redo</span>
        </button>
        <button class="draw-tool-btn" @click="clearDrawing" title="æ¸…é™¤">
            <span class="material-icons">delete</span>
        </button>
        <button class="draw-tool-btn" @click="exportDrawing" title="è¼¸å‡º">
            <span class="material-icons">photo_camera</span>
        </button>
        <button class="draw-tool-btn" @click="closeDrawToolbar" title="é—œé–‰">
            <span class="material-icons">close</span>
        </button>
    </div>

    <!-- === æ‹ç…§å°è©±æ¡† === -->
    <div v-if="isPhotoDialogVisible" class="photo-dialog-overlay" @click.self="closePhotoDialog">
        <div class="photo-dialog">
            <div class="photo-dialog-title">æ‹ç…§åŠ è¨»</div>

            <div class="photo-dialog-field">
                <label class="photo-dialog-label">å‚™è¨»æ–‡å­—</label>
                <input
                        type="text"
                        class="photo-dialog-input"
                        v-model="photoNote"
                        placeholder="è«‹è¼¸å…¥å‚™è¨»æ–‡å­—"
                />
            </div>

            <div class="photo-dialog-field">
                <label class="photo-dialog-label">åº§æ¨™ç³»çµ±</label>
                <select class="photo-dialog-select" v-model="photoCoordType">
                    <option value="wgs84">WGS84 (ç¶“ç·¯åº¦)</option>
                    <option value="twd97">TWD97 (3826)</option>
                </select>
            </div>

            <div class="photo-dialog-buttons">
                <button class="photo-dialog-button secondary" @click="closePhotoDialog">å–æ¶ˆ</button>
                <button class="photo-dialog-button primary" @click="openCamera">é–‹å•Ÿç›¸æ©Ÿ</button>
            </div>
        </div>
    </div>

    <!-- === å·¡å‹˜æ¨™è¨»å·¥å…·åˆ— === -->
    <div v-if="isAnnotationToolbarVisible" class="annotation-toolbar">
        <button class="annotation-tool-btn" :class="{active: currentAnnotationTool === 'arrow'}" @click="selectAnnotationTool('arrow')" title="ç•«ç®­é ­">
            <span class="material-icons">arrow_forward</span>
        </button>
        <button class="annotation-tool-btn" :class="{active: currentAnnotationTool === 'circle'}" @click="selectAnnotationTool('circle')" title="ç•«åœ“åœˆ">
            <span class="material-icons">circle</span>
        </button>
        <button class="annotation-tool-btn" :class="{active: currentAnnotationTool === 'text'}" @click="selectAnnotationTool('text')" title="æ¨™è¨˜æ–‡å­—">
            <span class="material-icons">text_fields</span>
        </button>
        <button class="annotation-tool-btn" @click="undoAnnotation" title="ä¸Šä¸€æ­¥">
            <span class="material-icons">undo</span>
        </button>
        <button class="annotation-tool-btn" @click="redoAnnotation" title="ä¸‹ä¸€æ­¥">
            <span class="material-icons">redo</span>
        </button>
        <button class="annotation-tool-btn" @click="clearAnnotation" title="æ¸…é™¤">
            <span class="material-icons">delete</span>
        </button>
        <button class="annotation-tool-btn" @click="openWorkTextDialog" title="å·¥ä½œæ–‡å­—">
            <span class="material-icons">description</span>
        </button>
        <button class="annotation-tool-btn" @click="addQRCode" title="æ–°å¢QR Code">
            <span class="material-icons">qr_code_2</span>
        </button>
        <button class="annotation-tool-btn" @click="exportAnnotation" title="è¼¸å‡º">
            <span class="material-icons">save_alt</span>
        </button>
        <button class="annotation-tool-btn" @click="closeAnnotationToolbar" title="é›¢é–‹">
            <span class="material-icons">close</span>
        </button>
    </div>

    <!-- === æ–‡å­—è¼¸å…¥å°è©±æ¡† === -->
    <div v-if="isTextInputDialogVisible" class="text-input-dialog-overlay" @click.self.stop="closeTextInputDialog">
        <div class="text-input-dialog" @click.stop>
            <div class="text-input-dialog-title">è¼¸å…¥æ–‡å­—</div>
            <input
                    type="text"
                    class="text-input-dialog-input"
                    v-model="annotationText"
                    placeholder="è«‹è¼¸å…¥è¦æ¨™è¨˜çš„æ–‡å­—"
                    @keyup.enter="confirmTextInput"
            />
            <div class="text-input-dialog-buttons">
                <button class="text-input-dialog-button secondary" @click="closeTextInputDialog">å–æ¶ˆ</button>
                <button class="text-input-dialog-button primary" @click="confirmTextInput">ç¢ºå®š</button>
            </div>
        </div>
    </div>

    <!-- === å·¥ä½œæ–‡å­—å°è©±æ¡† === -->
    <div v-if="isWorkTextDialogVisible" class="text-input-dialog-overlay" @click.self.stop="closeWorkTextDialog">
        <div class="text-input-dialog" @click.stop>
            <div class="text-input-dialog-title">è¼¸å…¥å·¥ä½œæ–‡å­—</div>
            <input
                    type="text"
                    class="text-input-dialog-input"
                    v-model="workText"
                    placeholder="è«‹è¼¸å…¥å·¥ä½œæ–‡å­—ï¼ˆå°‡é¡¯ç¤ºåœ¨ QR Code æ—ï¼‰"
                    @keyup.enter="confirmWorkText"
            />
            <div class="text-input-dialog-buttons">
                <button class="text-input-dialog-button secondary" @click="closeWorkTextDialog">å–æ¶ˆ</button>
                <button class="text-input-dialog-button primary" @click="confirmWorkText">ç¢ºå®š</button>
            </div>
        </div>
    </div>

    <!-- === å·¡å‹˜é¸æ“‡åˆ—è¡¨å°è©±æ¡† === -->
    <div v-if="inspectionListVisible" class="inspection-list-dialog-overlay" @click.self.stop="closeInspectionList">
        <div class="inspection-list-dialog" @click.stop>
            <div class="inspection-list-header">
                <div class="inspection-list-title">{{ inspectionListTitle }}</div>
                <button class="inspection-list-close" @click="closeInspectionList">
                    <span class="material-icons">close</span>
                </button>
            </div>
            <div class="inspection-list-body">
                <div v-if="inspectionListItems.length === 0" class="inspection-list-empty">
                    ç„¡è³‡æ–™
                </div>
                <div
                        v-for="(item, index) in inspectionListItems"
                        :key="index"
                        class="inspection-list-item"
                        @click="selectInspectionItem(item)"
                >
                    <div class="inspection-list-item-text">{{ item.text }}</div>
                </div>
            </div>
        </div>
    </div>

    <!-- === è»Œè·¡å·¡å‹˜ï¼šåœæ­¢æŒ‰éˆ• === -->
    <button v-if="isTracking" class="track-stop-button" @click.stop="stopTrackInspection">
        åœæ­¢<br>è¨˜éŒ„
    </button>

    <!-- === è»Œè·¡å·¡å‹˜ï¼šç‹€æ…‹æç¤º === -->
    <div v-if="isTracking" class="track-status-label">
        {{ trackStatus }}
    </div>

    <!-- === è»Œè·¡å·¡å‹˜ï¼šç¢ºèªå°è©±æ¡† === -->
    <div v-if="trackConfirmVisible" class="track-confirm-dialog-overlay" @click.self="cancelTrackConfirm">
        <div class="track-confirm-dialog" @click.stop>
            <div class="track-confirm-header">
                è»Œè·¡å·¡å‹˜ç¢ºèª
            </div>
            <div class="track-confirm-body">
                <!-- è¨­å‚™æ•¸é‡çµ±è¨ˆ -->
                <div class="device-counts">
                    <div class="device-counts-item">é›»æ¡¿: {{ trackDeviceCounts['é›»æ¡¿'] || 0 }}å€‹</div>
                    <div class="device-counts-item">äººå­”: {{ trackDeviceCounts['äººå­”'] || 0 }}å€‹</div>
                    <div class="device-counts-item">æ‰‹å­”: {{ trackDeviceCounts['æ‰‹å­”'] || 0 }}å€‹</div>
                    <div class="device-counts-item">äº¤æ¥ç®±: {{ trackDeviceCounts['äº¤æ¥ç®±'] || 0 }}å€‹</div>
                </div>

                <!-- è¨­å‚™æ¸…å–® -->
                <div class="device-list">
                    {{ trackDeviceList }}
                </div>

                <!-- æˆªåœ–é è¦½ -->
                <img v-if="trackScreenshot" :src="trackScreenshot" class="track-screenshot" />
            </div>
            <div class="track-confirm-actions">
                <button class="track-cancel-btn" @click="cancelTrackConfirm">å–æ¶ˆ</button>
                <button class="track-confirm-btn" @click="confirmTrackSend">ç¢ºèªé€å‡º</button>
            </div>
        </div>
    </div>

    <!-- === è·¨è¶Šçºœç·šï¼šé›»æ¡¿æ¸…å–®å°è©±æ¡† === -->
    <div v-if="poleListVisible" class="pole-list-overlay" @click.self="closePoleList">
        <div class="pole-list-dialog">
            <div class="pole-list-header">
                é¸æ“‡é›»æ¡¿
            </div>
            <div class="pole-list-body">
                <div
                        v-for="(pole, index) in nearbyPoles"
                        :key="index"
                        class="pole-list-item"
                        @click="onPoleSelected(pole)"
                >
                    <div class="pole-name">{{ pole.displayName }}</div>
                    <div class="pole-distance">è·é›¢: {{ pole.distance.toFixed(1) }} å…¬å°º</div>
                </div>
            </div>
            <div class="pole-list-footer">
                <button class="cable-cancel-btn" @click="closePoleList">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <!-- === è·¨è¶Šçºœç·šï¼šè¡¨å–®å°è©±æ¡† === -->
    <div v-if="cableFormVisible" class="cable-form-overlay" @click.self="closeCableForm">
        <div class="cable-form-container">
            <!-- Header -->
            <div class="cable-form-header">
                <button @click="closeCableForm">â†</button>
                <h3>è·¨è¶Šçºœç·šè³‡æ–™å»ºç«‹</h3>
            </div>

            <!-- Body -->
            <div class="cable-form-body">
                <!-- ä¸»å¹¹ -->
                <div class="form-section">
                    <label>ä¸»å¹¹</label>
                    <input type="text" v-model="cableFormData.mainPole" readonly>
                </div>

                <!-- æ˜¯å¦è·¨è¶Šé“è·¯ -->
                <div class="form-section">
                    <label>æ˜¯å¦è·¨è¶Šé“è·¯</label>
                    <select v-model="cableFormData.acrossroadtype">
                        <option value="Y">è·¨è¶Šé“è·¯</option>
                        <option value="N">æ²¿é“è·¯</option>
                        <option value="T">è·¨è¶Šéé›»åŒ–éµ</option>
                        <option value="C">è·¨è¶Šå¤§è»Šå‡ºå…¥å£</option>
                    </select>
                </div>

                <!-- ä»–ç«¯é™„æ›é» -->
                <div class="form-section">
                    <label>ä»–ç«¯é™„æ›é»</label>
                    <div class="form-row">
                        <div>
                            <select v-model="cableFormData.neighborFullNo">
                                <option value="">è«‹é¸æ“‡</option>
                                <option
                                        v-for="pole in nearbyPoles"
                                        :key="pole.fullNo"
                                        :value="pole.fullNo"
                                        :disabled="pole.fullNo === cableFormData.mainPole"
                                >
                                    {{ pole.displayName }}
                                </option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- é“è·¯å¯¬åº¦ -->
                <div class="form-section">
                    <label>é“è·¯å¯¬åº¦ï¼ˆå…¬å°ºï¼‰</label>
                    <input
                            type="number"
                            v-model.number="cableFormData.roadwidth"
                            min="3"
                            max="50"
                            step="0.1"
                            placeholder="è«‹è¼¸å…¥ 3-50"
                    >
                </div>

                <!-- å‚™è¨» -->
                <div class="form-section">
                    <label>å‚™è¨»</label>
                    <textarea
                            v-model="cableFormData.note"
                            placeholder="è«‹è¼¸å…¥å‚™è¨»ï¼ˆé¸å¡«ï¼‰"
                    ></textarea>
                </div>

                <!-- ç…§ç‰‡ -->
                <div class="form-section photo-section">
                    <label>ç…§ç‰‡ï¼ˆé¸å¡«ï¼‰</label>

                    <!-- æ²’æœ‰ç…§ç‰‡æ™‚ï¼šé¡¯ç¤ºé¸æ“‡æŒ‰éˆ• -->
                    <div v-if="!cableFormData.photoBase64" class="photo-buttons">
                        <button type="button" @click="selectPhoto">
                            ğŸ“· é¸æ“‡ç…§ç‰‡
                        </button>
                        <button type="button" @click="takePhoto">
                            ğŸ“¸ æ‹ç…§
                        </button>
                    </div>

                    <!-- æœ‰ç…§ç‰‡æ™‚ï¼šé¡¯ç¤ºé è¦½åœ– -->
                    <div v-else class="photo-preview">
                        <img :src="'data:image/png;base64,' + cableFormData.photoBase64">
                        <button type="button" @click="removePhoto" class="remove-photo-btn">
                            Ã—
                        </button>
                    </div>
                </div>

                <!-- é™„æ›çºœç·šæ¸…å–® -->
                <div class="pole-lines-section">
                    <div class="pole-lines-header">
                        <h4>é™„æ›çºœç·šï¼ˆé¸å¡«ï¼‰</h4>
                        <button type="button" class="add-line-btn" @click="addPoleLine">
                            + æ–°å¢
                        </button>
                    </div>

                    <div v-if="cableFormData.poleLines.length === 0" style="color: #666; font-size: 14px;">
                        å°šæœªæ–°å¢é™„æ›çºœç·š
                    </div>

                    <div
                            v-for="(line, index) in cableFormData.poleLines"
                            :key="index"
                            class="pole-line-item"
                    >
                        <div class="pole-line-header">
                            <span class="pole-line-number">ç¬¬ {{ index + 1 }} æ¢çºœç·š</span>
                            <button type="button" class="remove-line-btn" @click="removePoleLine(index)">
                                åˆªé™¤
                            </button>
                        </div>

                        <div class="pole-line-fields">
                            <!-- æ¥­è€… -->
                            <div>
                                <label style="display: block; margin-bottom: 5px; font-size: 13px;">æ¥­è€…</label>
                                <select v-model="line.vendername" @change="onVenderChange(index)">
                                    <option value="">è«‹é¸æ“‡</option>
                                    <option
                                            v-for="vender in vendersList"
                                            :key="vender.vendersn"
                                            :value="vender.vendername"
                                    >
                                        {{ vender.vendername }}
                                    </option>
                                </select>
                            </div>

                            <!-- é™„æ›æ•¸é‡ -->
                            <div>
                                <label style="display: block; margin-bottom: 5px; font-size: 13px;">é™„æ›æ•¸é‡</label>
                                <input type="number" v-model.number="line.linenum" min="1" placeholder="è«‹è¼¸å…¥æ•¸é‡">
                            </div>

                            <!-- çºœç·šé«˜åº¦ -->
                            <div>
                                <label style="display: block; margin-bottom: 5px; font-size: 13px;">çºœç·šé«˜åº¦ï¼ˆå…¬å°ºï¼‰</label>
                                <input type="number" v-model.number="line.height" min="0" step="0.1" placeholder="è«‹è¼¸å…¥é«˜åº¦">
                            </div>

                            <!-- æ˜¯å¦ç§Ÿç”¨ -->
                            <div class="checkbox-field">
                                <input type="checkbox" v-model="line.isRentChecked" @change="onRentChange(index)">
                                <label style="margin: 0;">æ˜¯å¦ç§Ÿç”¨</label>
                            </div>

                            <!-- ç§Ÿç”¨æ—¥æœŸï¼ˆåªæœ‰ç§Ÿç”¨æ™‚æ‰é¡¯ç¤ºï¼‰ -->
                            <div v-if="line.isRentChecked">
                                <label style="display: block; margin-bottom: 5px; font-size: 13px;">ç§Ÿç”¨æ—¥æœŸ</label>
                                <input type="date" v-model="line.leasedate">
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Footer -->
            <div class="cable-form-footer">
                <button type="button" class="cable-cancel-btn" @click="closeCableForm">å–æ¶ˆ</button>
                <button type="button" class="cable-submit-btn" @click="submitCableData">ç¢ºå®šé€å‡º</button>
            </div>
        </div>
    </div>

    <!-- === æ–°å¢: Snackbar DOM === -->
    <div :class="['snackbar', showSnackbar ? 'show' : '']">{{ snackbarText }}</div>
    <!-- === æ¯”ä¾‹å°º ScaleBar(è‡ªè¨‚) === -->
    <div id="customScaleBar">
        <span id="scaleText">æ¯”ä¾‹: 1:--</span>
    </div>
</div>

<script>
    // æå‰å®šç¾©å…¨åŸŸè®Šæ•¸å’Œå‡½æ•¸ï¼ˆä¾› Android å‘¼å«ï¼‰
    let appToken = '';
    let appArea = '';

    window.setAppToken = (token) => {
        appToken = token;
        console.log("Token set:", token);
    };

    window.setAppArea = (area) => {
        appArea = area;
        console.log("Area set:", area);
    };

    const { createApp, ref, reactive, onMounted, markRaw, watch, nextTick } = Vue;

    createApp({
      setup() {
        const isMainMenuVisible = ref(false);
        const currentSubMenu = ref(null);
        const isLayerDialogVisible = ref(false);
        const selectedBasemap = ref('CHTGIS'); // é è¨­æ”¹ç‚º CHTGIS
        const isLocating = ref(false);
        const isLocationActive = ref(false); // è¿½è¹¤å®šä½æ˜¯å¦å•Ÿç”¨
        const isQueryDialogVisible = ref(false); // æŸ¥è©¢å°è©±æ¡†
        const isResultListVisible = ref(false); // çµæœåˆ—è¡¨å°è©±æ¡†
        const isCoordinateDialogVisible = ref(false); // åº§æ¨™æŸ¥è©¢å°è©±æ¡†
        const isDistrictListVisible = ref(false); // è¡Œæ”¿å€æ¸…å–®å°è©±æ¡†
        const districtList = ref([]); // è¡Œæ”¿å€åˆ—è¡¨
        const currentCity = ref(''); // ç•¶å‰åŸå¸‚
        const currentQueryType = ref(''); // ç•¶å‰æŸ¥è©¢é¡å‹
        const queryParams = reactive({}); // æŸ¥è©¢åƒæ•¸ï¼ˆå‹•æ…‹ï¼‰
        const queryResults = ref([]); // æŸ¥è©¢çµæœ
        const coordinateParams = reactive({
            x: '',
            y: '',
            coordSystem: 'TWD97' // é è¨­ TWD97
        }); // åº§æ¨™æŸ¥è©¢åƒæ•¸
        const isNavigationDialogVisible = ref(false); // å°èˆªç›®æ¨™å°è©±æ¡†
        const isDrawToolbarVisible = ref(false); // ç¹ªåœ–å·¥å…·åˆ—
        const currentDrawTool = ref(null); // ç•¶å‰ç¹ªåœ–å·¥å…·: 'point', 'polyline', 'polygon'
        const drawHistory = reactive({ past: [], future: [] }); // ç¹ªåœ–æ­·å²è¨˜éŒ„
        const isPhotoDialogVisible = ref(false); // æ‹ç…§å°è©±æ¡†
        const photoNote = ref(''); // å‚™è¨»æ–‡å­—
        const photoCoordType = ref('wgs84'); // åº§æ¨™ç³»çµ±é¡å‹

        // å·¡å‹˜æ¨™è¨»åŠŸèƒ½
        const isAnnotationToolbarVisible = ref(false); // æ¨™è¨»å·¥å…·åˆ—
        const currentAnnotationTool = ref(null); // ç•¶å‰æ¨™è¨»å·¥å…·
        const isTextInputDialogVisible = ref(false); // æ–‡å­—è¼¸å…¥å°è©±æ¡†
        const annotationText = ref(''); // æ¨™è¨»æ–‡å­—
        const isWorkTextDialogVisible = ref(false); // å·¥ä½œæ–‡å­—å°è©±æ¡†
        const workText = ref(''); // å·¥ä½œæ–‡å­—ï¼ˆé¡¯ç¤ºåœ¨ QR Code æ—ï¼‰
        const annotationHistory = reactive({ past: [], future: [] }); // æ¨™è¨»æ­·å²
        let annotationLayer = null; // æ¨™è¨»åœ–å±¤
        let qrCodePoint = null; // QR Code ä½ç½®

        // å·¡å‹˜åŠŸèƒ½è®Šæ•¸
        const inspectionListVisible = ref(false); // å·¡å‹˜åˆ—è¡¨å°è©±æ¡†å¯è¦‹æ€§
        const inspectionListTitle = ref(''); // å°è©±æ¡†æ¨™é¡Œ
        const inspectionListItems = ref([]); // åˆ—è¡¨é …ç›®
        let inspectionListType = ''; // ç•¶å‰åˆ—è¡¨é¡å‹ï¼š'exgno', 'road', 'device'

        // LDAPï¼ˆå¾ Android å–å¾—ï¼‰
        const ldap = ref('');

        // === è»Œè·¡å·¡å‹˜è®Šæ•¸ ===
        const isTracking = ref(false); // æ˜¯å¦æ­£åœ¨è¨˜éŒ„è»Œè·¡
        const trackStatus = ref(''); // è»Œè·¡ç‹€æ…‹æ–‡å­—
        const trackConfirmVisible = ref(false); // ç¢ºèªå°è©±æ¡†å¯è¦‹æ€§
        const trackDeviceCounts = ref({}); // å„é¡è¨­å‚™æ•¸é‡
        const trackDeviceList = ref(''); // è¨­å‚™æ¸…å–®æ–‡å­—
        const trackScreenshot = ref(''); // æˆªåœ– base64

        // ===== è·¨è¶Šçºœç·šç‹€æ…‹ =====
        const poleListVisible = ref(false); // é›»æ¡¿æ¸…å–®å°è©±æ¡†
        const cableFormVisible = ref(false); // çºœç·šè¡¨å–®å°è©±æ¡†
        const nearbyPoles = ref([]); // é™„è¿‘é›»æ¡¿æ¸…å–®
        const vendersList = ref([]); // æ¥­è€…æ¸…å–®
        const cableFormData = ref({
            mainPole: '', // ä¸»å¹¹é›»æ¡¿
            acrossroadtype: 'N', // è·¨è¶Šé“è·¯é¡å‹
            neighborFullNo: '', // ä»–ç«¯é™„æ›é»
            roadwidth: 3, // é“è·¯å¯¬åº¦
            note: '', // å‚™è¨»
            photoBase64: null, // ç…§ç‰‡ Base64
            poleLines: [] // é™„æ›çºœç·šæ¸…å–®
        });

        // ä½¿ç”¨ window ç‰©ä»¶ç¢ºä¿å…¨åŸŸå¯å­˜å–
        if (!window.navigationTargetsData) {
            window.navigationTargetsData = [];
        }

        // Vue ref ç”¨æ–¼é¡¯ç¤ºåœ¨ UI
        const navigationTargets = ref([]);

        // æŸ¥è©¢é…ç½® - å¯æ“´å±•å¤šç¨®æŸ¥è©¢
        const queryConfigs = {
            'äººå­”æŸ¥è©¢': {
                layerGroup: 'ç®¡é“åœ–',
                layerName: 'ç®¡é“äººå­”(G60)',
                fields: [
                    { key: 'centoff', label: 'äº¤æ›å±€', placeholder: 'è«‹è¼¸å…¥äº¤æ›å±€', uppercase: true },
                    { key: 'manholeNo', label: 'äººå­”åç¨±', placeholder: 'è«‹è¼¸å…¥äººå­”åç¨±', uppercase: false }
                ],
                buildWhereClause: (params) => {
                    return `CENTOFF like '%${params.centoff}%' and NO_='${params.manholeNo}'`;
                },
                displayFields: (attributes) => ({
                    title: attributes.NO_ || 'æœªå‘½å',
                    subtitle: `äº¤æ›å±€: ${attributes.CENTOFF || 'N/A'}`
                })
            },
            'æ‰‹å­”æŸ¥è©¢': {
                layerGroup: 'ç®¡é“åœ–',
                layerName: 'ç®¡é“æ‰‹å­”(G61)',
                fields: [
                    { key: 'centoff', label: 'äº¤æ›å±€', placeholder: 'è«‹è¼¸å…¥äº¤æ›å±€', uppercase: true },
                    { key: 'handNo', label: 'æ‰‹å­”åç¨±', placeholder: 'è«‹è¼¸å…¥æ‰‹å­”åç¨±', uppercase: false }
                ],
                buildWhereClause: (params) => {
                    // å¾…è£œå……æ­£ç¢ºæ¬„ä½åç¨±
                    return `CENTOFF like '%${params.centoff}%' and NO_='${params.handNo}'`;
                },
                displayFields: (attributes) => ({
                    title: attributes.NO_ || 'æœªå‘½å',
                    subtitle: `äº¤æ›å±€: ${attributes.CENTOFF || 'N/A'}`
                })
            },
            'é›»æ¡¿æŸ¥è©¢': {
                layerGroup: 'é›»çºœåœ–',
                layerName: 'çºœé›»æ¡¿(G69)',
                fields: [
                    { key: 'centoff', label: 'äº¤æ›å±€', placeholder: 'è«‹è¼¸å…¥äº¤æ›å±€', uppercase: true },
                    { key: 'poleNo', label: 'é›»æ¡¿ç·¨è™Ÿ', placeholder: 'è«‹è¼¸å…¥é›»æ¡¿ç·¨è™Ÿ', uppercase: false }
                ],
                buildWhereClause: (params) => {
                    return `CENTOFF like '%${params.centoff.toUpperCase()}%' and (NO_='${params.poleNo}' or POLNAM like '%${params.poleNo}%')`;
                },
                displayFields: (attributes) => ({
                    title: attributes.NO_ || attributes.POLNAM || 'æœªå‘½å',
                    subtitle: `äº¤æ›å±€: ${attributes.CENTOFF || 'N/A'}`
                })
            },
            'äº¤æ¥ç®±æŸ¥è©¢(å…‰)': {
                layerGroup: 'å…‰çºœåœ–',
                layerName: 'æˆ¶å¤–çµ‚ç«¯',
                fields: [
                    { key: 'centoff', label: 'äº¤æ›å±€', placeholder: 'è«‹è¼¸å…¥äº¤æ›å±€', uppercase: true },
                    { key: 'accno', label: 'äº¤æ¥ç®±ç·¨è™Ÿ', placeholder: 'è«‹è¼¸å…¥äº¤æ¥ç®±ç·¨è™Ÿ', uppercase: false }
                ],
                buildWhereClause: (params) => {
                    return `CENTOFF LIKE '%${params.centoff.toUpperCase()}%' and ACCNO='${params.accno}'`;
                },
                displayFields: (attributes) => ({
                    title: attributes.ACCNO || 'æœªå‘½å',
                    subtitle: `äº¤æ›å±€: ${attributes.CENTOFF || 'N/A'}`
                })
            },
            'äº¤æ¥ç®±æŸ¥è©¢(çºœ)': {
                layerGroup: 'é›»çºœåœ–',
                layerName: 'çºœäº¤æ¥ç®±(G71)',
                fields: [
                    { key: 'centoff', label: 'äº¤æ›å±€', placeholder: 'è«‹è¼¸å…¥äº¤æ›å±€', uppercase: true },
                    { key: 'crossno_c', label: 'çºœäº¤æ¥ç®±è™Ÿ', placeholder: 'è«‹è¼¸å…¥çºœäº¤æ¥ç®±è™Ÿ', uppercase: true }
                ],
                buildWhereClause: (params) => {
                    return `CENTOFF like '%${params.centoff.toUpperCase()}%' and CROSSNO_C='${params.crossno_c.toUpperCase()}'`;
                },
                displayFields: (attributes) => ({
                    title: attributes.CROSSNO_C || 'æœªå‘½å',
                    subtitle: `äº¤æ›å±€: ${attributes.CENTOFF || 'N/A'}, å¸³è™Ÿ: ${attributes.ACCNO || 'N/A'}`
                })
            },
            'äº¤æ¥ç®±æŸ¥è©¢(FTTH)': {
                layerGroup: 'é…ç·šå…‰çºœFTTH',
                layerName: 'å…‰äº¤æ¥ç®±',
                fields: [
                    { key: 'centoff', label: 'äº¤æ›å±€', placeholder: 'è«‹è¼¸å…¥äº¤æ›å±€', uppercase: true },
                    { key: 'accno', label: 'äº¤æ¥ç®±è™Ÿ', placeholder: 'è«‹è¼¸å…¥äº¤æ¥ç®±è™Ÿ', uppercase: true }
                ],
                buildWhereClause: (params) => {
                    return `CENTOFF LIKE '%${params.centoff.toUpperCase()}%' and ACCNO='${params.accno.toUpperCase()}'`;
                },
                displayFields: (attributes) => ({
                    title: attributes.ACCNO || 'æœªå‘½å',
                    subtitle: `äº¤æ›å±€: ${attributes.CENTOFF || 'N/A'}`
                })
            },
            'å…‰çºœçµ‚ç«¯æŸ¥è©¢': {
                layerGroup: 'å…‰çºœåœ–',
                layerName: 'å…‰çºœçµ‚ç«¯',
                fields: [
                    { key: 'centoff', label: 'äº¤æ›å±€å', placeholder: 'è«‹è¼¸å…¥äº¤æ›å±€å', uppercase: true },
                    { key: 'accno', label: 'ç®±è™Ÿ', placeholder: 'è«‹è¼¸å…¥ç®±è™Ÿ', uppercase: false }
                ],
                buildWhereClause: (params) => {
                    return `CENTOFF LIKE '%${params.centoff.toUpperCase()}%' and ACCNO='${params.accno}'`;
                },
                displayFields: (attributes) => ({
                    title: attributes.ACCNO || 'æœªå‘½å',
                    subtitle: `äº¤æ›å±€: ${attributes.CENTOFF || 'N/A'}`
                })
            },
            'å…‰å‡ºç·šé»æŸ¥è©¢': {
                layerGroup: 'å…‰çºœåœ–',
                layerName: 'å…‰ç¶²è·¯è¨­å‚™',
                fields: [
                    { key: 'centoff', label: 'äº¤æ›å±€å', placeholder: 'è«‹è¼¸å…¥äº¤æ›å±€å', uppercase: false },
                    { key: 'accno', label: 'ç®±è™Ÿ', placeholder: 'è«‹è¼¸å…¥ç®±è™Ÿ', uppercase: false }
                ],
                buildWhereClause: (params) => {
                    return `CENTOFF = '${params.centoff}' AND ACCNO='${params.accno}'`;
                },
                displayFields: (attributes) => ({
                    title: attributes.ACCNO || 'æœªå‘½å',
                    subtitle: `äº¤æ›å±€: ${attributes.CENTOFF || 'N/A'}`
                })
            },
            'å¼•ä¸Šé›»çºœæŸ¥è©¢': {
                layerGroup: 'é›»çºœåœ–',
                layerName: 'å¼•ä¸Šé›»çºœ(G87)',
                fields: [
                    { key: 'centoff', label: 'äº¤æ›å±€', placeholder: 'è«‹è¼¸å…¥äº¤æ›å±€', uppercase: false },
                    { key: 'crossno1', label: 'ç®±è™Ÿ', placeholder: 'è«‹è¼¸å…¥ç®±è™Ÿ', uppercase: false },
                    { key: 'dpair1', label: 'ç™¾å°', placeholder: 'è«‹è¼¸å…¥ç™¾å°', uppercase: false },
                    { key: 'd_epdesc1', label: 'èŠ¯ç·šç¯„åœ', placeholder: 'è«‹è¼¸å…¥èŠ¯ç·šç¯„åœï¼Œå¦‚: 1-20', uppercase: false }
                ],
                buildWhereClause: (params) => {
                    return `CENTOFF LIKE '${params.centoff}' and CROSSNO1 LIKE '%${params.crossno1}%' AND DPAIR1='${params.dpair1}'`;
                },
                displayFields: (attributes) => ({
                    title: `${attributes.CROSSNO1 || 'æœªå‘½å'} - ${attributes.DPAIR1 || ''}`,
                    subtitle: `äº¤æ›å±€: ${attributes.CENTOFF || 'N/A'}, èŠ¯ç·š: ${attributes.D_EPDESC1 || 'N/A'}`
                }),
                isLineQuery: true  // æ¨™è¨˜é€™æ˜¯ç·šæ¢æŸ¥è©¢ï¼Œéœ€è¦ç‰¹æ®Šè™•ç†
            },
            'åœ°å€æŸ¥è©¢': {
                layerGroup: 'baseDyLayer',
                layerName: 'åœ°å€é»',
                fields: [
                    { key: 'fulladdress', label: 'åœ°å€é—œéµå­—', placeholder: 'è«‹è¼¸å…¥åœ°å€é—œéµå­—', uppercase: false }
                ],
                buildWhereClause: (params) => {
                    return `FULLADDRESS like '%${params.fulladdress}%'`;
                },
                displayFields: (attributes) => ({
                    title: attributes.FULLADDRESS || 'æœªå‘½å',
                    subtitle: 'åœ°å€æŸ¥è©¢çµæœ'
                })
            },
            'åœ°æ¨™æŸ¥è©¢': {
                layerGroup: 'å…¨å€åŸºæœ¬åœ–',
                layerName: 'é‡è¦åœ°æ¨™(T_Locater)',
                fields: [
                    { key: 'tname', label: 'é„‰é®å€å', placeholder: 'è«‹è¼¸å…¥é„‰é®å€å', uppercase: false },
                    { key: 'name', label: 'åœ°æ¨™åç¨±', placeholder: 'è«‹è¼¸å…¥åœ°æ¨™åç¨±', uppercase: false }
                ],
                buildWhereClause: (params) => {
                    return `NAME like '%${params.name}%' and TNAME='${params.tname}'`;
                },
                displayFields: (attributes) => ({
                    title: attributes.NAME || 'æœªå‘½å',
                    subtitle: `é„‰é®å€: ${attributes.TNAME || 'N/A'}`
                })
            },
            'é‡Œç¨‹ç¢‘æŸ¥è©¢': {
                layerGroup: 'å…¨å€åŸºæœ¬åœ–',
                layerName: 'é‡Œç¨‹ç¢‘',
                fields: [
                    { key: 'public_id', label: 'çœç¸£é„‰é“å', placeholder: 'è«‹è¼¸å…¥çœç¸£é„‰é“å', uppercase: false },
                    { key: 'km', label: 'é‡Œç¨‹æ•¸', placeholder: 'è«‹è¼¸å…¥é‡Œç¨‹æ•¸', uppercase: false }
                ],
                buildWhereClause: (params) => {
                    return `PUBLIC_ID = '${params.public_id}' and KM=${params.km}`;
                },
                displayFields: (attributes) => ({
                    title: `${attributes.PUBLIC_ID || 'æœªå‘½å'} ${attributes.KM || ''}K`,
                    subtitle: `é“è·¯: ${attributes.PUBLIC_ID || 'N/A'}, é‡Œç¨‹: ${attributes.KM || 'N/A'}K`
                })
            }
            // å…¶ä»–æŸ¥è©¢é¡å‹å¾…è£œå……...
        };

        // åœ–å±¤åˆ—è¡¨è³‡æ–™
        const layerList = reactive([]);

        // Snackbar æ–°å¢ç‹€æ…‹
        const showSnackbar = ref(false);
        const snackbarText = ref("");
        let snackbarTimer = null;

        // å­é¸å–®è³‡æ–™ (å‹•æ…‹æ ¹æ“š appArea ç”¢ç”Ÿ)
        const getSubMenuItems = () => {
            const areaUpper = appArea.toUpperCase();
            let constructionLabel = 'ä»Šæ—¥æ–½å·¥ä½ç½®';

            if (areaUpper.includes('TP')) {
                constructionLabel = 'å°åŒ—å¸‚ä»Šæ—¥æ–½å·¥ä½ç½®';
            } else if (areaUpper.includes('NP')) {
                constructionLabel = 'æ–°åŒ—å¸‚ä»Šæ—¥æ–½å·¥ä½ç½®';
            } else if (areaUpper.includes('TY')) {
                constructionLabel = 'æ¡ƒåœ’å¸‚ä»Šæ—¥æ–½å·¥ä½ç½®';
            }

            return {
                'æŸ¥è©¢': ["äººå­”æŸ¥è©¢", "æ‰‹å­”æŸ¥è©¢", "é›»æ¡¿æŸ¥è©¢", "äº¤æ¥ç®±æŸ¥è©¢(å…‰)", "äº¤æ¥ç®±æŸ¥è©¢(çºœ)", "äº¤æ¥ç®±æŸ¥è©¢(FTTH)", "åœ°å€æŸ¥è©¢", "åœ°æ¨™æŸ¥è©¢", "é‡Œç¨‹ç¢‘æŸ¥è©¢", "å…‰çºœçµ‚ç«¯æŸ¥è©¢", "å¼•ä¸Šé›»çºœæŸ¥è©¢", "å…‰å‡ºç·šé»æŸ¥è©¢"],
                'å°èˆª': ["ä½ç½®å®šä½", "åº§æ¨™æŸ¥è©¢", "å°èˆªç›®æ¨™"],
                'å·¡å‹˜': ["é“è·¯å·¡å‹˜ç‹€æ…‹æŸ¥è©¢", "è»Œè·¡å·¡å‹˜", "è·¨è¶Šçºœç·šè³‡æ–™å»ºç«‹", "å·¡å‹˜æ”¹å–„å›å ±", "ä¸Šæ¬¡è»Œè·¡é‡é€", constructionLabel],
                'å…¶ä»–': ["é‡æ¸¬ç¹ªåœ–", "æŠ“åœ°åœ–ç•«é¢", "ç™»å‡º", "æ‹ç…§åŠ è¨»æ–‡å­—èˆ‡åº§æ¨™", "å·¡å‹˜æ”¹å–„è¨­è¨ˆåœ–", "æ¸…é™¤ç•«é¢ç¹ªåœ–", "åˆ‡æ›äººå“¡"]
            };
        };

        const subMenuItems = ref({
            'æŸ¥è©¢': ["äººå­”æŸ¥è©¢", "æ‰‹å­”æŸ¥è©¢", "é›»æ¡¿æŸ¥è©¢", "äº¤æ¥ç®±æŸ¥è©¢(å…‰)", "äº¤æ¥ç®±æŸ¥è©¢(çºœ)", "äº¤æ¥ç®±æŸ¥è©¢(FTTH)", "åœ°å€æŸ¥è©¢", "åœ°æ¨™æŸ¥è©¢", "é‡Œç¨‹ç¢‘æŸ¥è©¢", "å…‰çºœçµ‚ç«¯æŸ¥è©¢", "å¼•ä¸Šé›»çºœæŸ¥è©¢", "å…‰å‡ºç·šé»æŸ¥è©¢"],
            'å°èˆª': ["ä½ç½®å®šä½", "åº§æ¨™æŸ¥è©¢", "å°èˆªç›®æ¨™"],
            'å·¡å‹˜': ["é“è·¯å·¡å‹˜ç‹€æ…‹æŸ¥è©¢", "è»Œè·¡å·¡å‹˜", "è·¨è¶Šçºœç·šè³‡æ–™å»ºç«‹", "å·¡å‹˜æ”¹å–„å›å ±", "ä¸Šæ¬¡è»Œè·¡é‡é€", "å°åŒ—å¸‚ä»Šæ—¥æ–½å·¥ä½ç½®"],
            'å…¶ä»–': ["é‡æ¸¬ç¹ªåœ–", "æŠ“åœ°åœ–ç•«é¢", "ç™»å‡º", "æ‹ç…§åŠ è¨»æ–‡å­—èˆ‡åº§æ¨™", "å·¡å‹˜æ”¹å–„è¨­è¨ˆåœ–", "æ¸…é™¤ç•«é¢ç¹ªåœ–", "åˆ‡æ›äººå“¡"]
        });

        // ArcGIS ç‰©ä»¶
        let map = null;
        let view = null;
        let Sketch = null; // ArcGIS Sketch widget
        let GraphicsLayer = null;
        let sketchLayer = null; // ç¹ªåœ–åœ–å±¤
        let sketchWidget = null; // Sketch widget å¯¦ä¾‹
        let measurementLayer = null; // æ¸¬é‡æ¨™ç±¤åœ–å±¤
        let coordinateClickHandler = null; // åº§æ¨™é¡¯ç¤ºçš„ click äº‹ä»¶è™•ç†å™¨
        let MapImageLayerClass = null;
        let WMTSLayerClass = null;
        let reactiveUtils = null;
        let IdentityManager = null;
        let LocateWidget = null;
        let GraphicClass = null;
        let SimpleMarkerSymbolClass = null;
        let FeatureLayerClass = null;
        let TextSymbolClass = null;
        let PointClass = null;
        let projectionModule = null;
        let SpatialReferenceClass = null;
        let PolylineClass = null;
        let PolygonClass = null;
        let SimpleLineSymbolClass = null;
        let geometryEngine = null;
        let MultipointClass = null;

        // é è¨­å€¼
        if (!appArea) appArea = "tp";
        if (!appToken) appToken = "";
        let baseUrl = "https://gisapp.cht.com.tw/arcgis107/rest/services/";

        // CHT åº•åœ–ç‰©ä»¶
        let baseLayer = null;
        let baseDyLayer = null;
        let chtBasemapScaleHandle = null;

        // NLSC WMTS åº•åœ–ç‰©ä»¶
        let nlscWmtsLayer = null;

        // Locate widget
        let locateWidget = null;
        let locationGraphic = null; // å„²å­˜å®šä½æ¨™è¨˜

        // æ›´æ–° setAppToken å’Œ setAppAreaï¼ˆé€£çµåˆ° Vueï¼‰
        window.setAppToken = (token) => {
            appToken = token;
            console.log("Token set:", token);

            if (IdentityManager && token) {
                IdentityManager.registerToken({
                    server: "https://gisapp.cht.com.tw/arcgis107/rest/services",
                    token: token
                });
            }
        };

        window.setAppArea = (area) => {
            appArea = area;
            console.log("Area set:", area);
            subMenuItems.value = getSubMenuItems();
            initLayerList();
            if (map && selectedBasemap.value === 'CHTGIS') {
                setupChtBasemap();
            }
        };

        const initLayerList = () => {
             layerList.splice(0, layerList.length);

             let sname = appArea;
             let snameUpper = appArea.toUpperCase();

             const layersConfig = [
                 { name: "ç®¡é“åœ–", url: `${baseUrl}${sname}conduit/MapServer` },
                 { name: "é•·é€”å…‰çºœåœ–", url: `${baseUrl}TW/longhaul/MapServer` },
                 { name: "é›»çºœåœ–", url: `${baseUrl}${sname}cable/MapServer` },
                 { name: "å¹¹ç·šåœ–", url: `${baseUrl}${sname}mfmain/MapServer` },
                 { name: "å…‰çºœåœ–", url: `${baseUrl}${sname}fiber/MapServer` },
                 { name: "å…¨å€åŸºæœ¬åœ–", url: `${baseUrl}TW/twbase/MapServer` },
                 { name: "é…ç·šå…‰çºœFTTH", url: `${baseUrl}${snameUpper}_FTTH/MapServer` },
                 { name: "ä¸­ç¹¼å…‰çºœåœ–", url: `${baseUrl}TW/trunk/MapServer` }
             ];

             layersConfig.forEach(cfg => {
                 layerList.push({
                     name: cfg.name,
                     url: cfg.url,
                     isEnabled: false,
                     layerObj: null
                 });
             });
        };

        // å°‹æ‰¾åœ–å±¤ URL
        const findLayerUrl = (layerGroup, layerName) => {
            if (!layerGroup || !layerGroup.sublayers) return "";
            const baseUrl = layerGroup.url.endsWith("/")
                ? layerGroup.url
                : layerGroup.url + "/";

            // æ·±åº¦æœå°‹æ‰€æœ‰ sublayers(éè¿´)
            function searchSublayers(sublayers) {
                for (let sl of sublayers) {
                    const name = sl.title?.trim() ?? "";
                    // åç¨±ç›¸ç¬¦ â†’ ç›´æ¥å›å‚³å®Œæ•´ URL
                    if (name.toLowerCase() === layerName.toLowerCase()) {
                        return baseUrl + sl.id;
                    }
                    // æœ‰å­å±¤ â†’ å¾€ä¸‹æ‰¾
                    if (sl.sublayers && sl.sublayers.length > 0) {
                        const result = searchSublayers(sl.sublayers);
                        if (result) return result;
                    }
                }
                return null;
            }
            return searchSublayers(layerGroup.sublayers) || "";
        };

        // æª¢æŸ¥èŠ¯ç·šç¯„åœæ˜¯å¦åœ¨å°æ•¸ç¯„åœå…§
        const checklinein = (dpair, targetDpair) => {
            if (!dpair || !targetDpair) return false;

            // ç§»é™¤ "é€£", "tie", "Tie" å­—æ¨£
            dpair = dpair.replace(/é€£/g, '');
            dpair = dpair.replace(/tie/gi, '');

            // å¦‚æœåŒ…å«æ‹¬è™Ÿï¼Œæå–æ‹¬è™Ÿå…§çš„å…§å®¹
            if (dpair.includes('(')) {
                const st = dpair.indexOf('(');
                const et = dpair.indexOf(')');
                dpair = dpair.substring(st + 1, et);
            }

            // åˆå§‹åŒ–å°æ•¸åˆ—è¡¨
            const nolist = {};

            // è§£æç¯„åœä¸¦æ¨™è¨˜å­˜åœ¨çš„å°æ•¸
            const parseDpairRange = (rangeStr) => {
                if (rangeStr.includes(',')) {
                    const array = rangeStr.split(',');
                    array.forEach(tmp => {
                        tmp = tmp.trim();
                        if (tmp.includes('-')) {
                            const parts = tmp.split('-');
                            const sno = parseInt(parts[0].trim());
                            const eno = parseInt(parts[1].trim());
                            if (sno > 0 && eno > 0) {
                                for (let v = sno; v <= eno; v++) {
                                    nolist[v] = "1";
                                }
                            }
                        } else {
                            const num = parseInt(tmp);
                            if (!isNaN(num)) {
                                nolist[num] = "1";
                            }
                        }
                    });
                } else {
                    const tmp = rangeStr.trim();
                    if (tmp.includes('-')) {
                        const parts = tmp.split('-');
                        const sno = parseInt(parts[0].trim());
                        const eno = parseInt(parts[1].trim());
                        if (sno > 0 && eno > 0) {
                            for (let v = sno; v <= eno; v++) {
                                nolist[v] = "1";
                            }
                        }
                    } else {
                        const num = parseInt(tmp);
                        if (!isNaN(num)) {
                            nolist[num] = "1";
                        }
                    }
                }
            };

            // è§£æ dpair
            parseDpairRange(dpair);

            // æª¢æŸ¥ç›®æ¨™æ˜¯å¦éƒ½åœ¨åˆ—è¡¨ä¸­
            const checkTargetInList = (targetStr) => {
                if (targetStr.includes(',')) {
                    const array = targetStr.split(',');
                    for (let i = 0; i < array.length; i++) {
                        let tmp = array[i].trim();
                        if (tmp.includes('-')) {
                            const parts = tmp.split('-');
                            const sno = parseInt(parts[0].trim());
                            const eno = parseInt(parts[1].trim());
                            if (sno > 0 && eno > 0) {
                                for (let v = sno; v <= eno; v++) {
                                    if (nolist[v] !== "1") {
                                        return false;
                                    }
                                }
                            }
                        } else {
                            const num = parseInt(tmp);
                            if (!isNaN(num) && nolist[num] !== "1") {
                                return false;
                            }
                        }
                    }
                } else {
                    const tmp = targetStr.trim();
                    if (tmp.includes('-')) {
                        const parts = tmp.split('-');
                        const sno = parseInt(parts[0].trim());
                        const eno = parseInt(parts[1].trim());
                        if (sno > 0 && eno > 0) {
                            for (let v = sno; v <= eno; v++) {
                                if (nolist[v] !== "1") {
                                    return false;
                                }
                            }
                        }
                    } else {
                        const num = parseInt(tmp);
                        if (!isNaN(num) && nolist[num] !== "1") {
                            return false;
                        }
                    }
                }
                return true;
            };

            return checkTargetInList(targetDpair);
        };

        // å°‡è¼¸å…¥è½‰ç‚ºå¤§å¯«ï¼ˆé€šç”¨ï¼‰
        const upperCaseInput = (key) => {
            if (queryParams[key]) {
                queryParams[key] = queryParams[key].toUpperCase();
            }
        };

        // é–‹å•ŸæŸ¥è©¢å°è©±æ¡†
        const openQueryDialog = (queryType) => {
            currentQueryType.value = queryType;

            // æª¢æŸ¥æŸ¥è©¢é…ç½®æ˜¯å¦å­˜åœ¨
            if (!queryConfigs[queryType]) {
                snackbarText.value = `æŸ¥è©¢é¡å‹ "${queryType}" å°šæœªé…ç½®`;
                showSnackbar.value = true;
                if (snackbarTimer) clearTimeout(snackbarTimer);
                snackbarTimer = setTimeout(() => {
                    showSnackbar.value = false;
                }, 3000);
                return;
            }

            // æ¸…ç©ºä¸¦åˆå§‹åŒ–æŸ¥è©¢åƒæ•¸
            Object.keys(queryParams).forEach(key => delete queryParams[key]);
            const config = queryConfigs[queryType];
            config.fields.forEach(field => {
                queryParams[field.key] = '';
            });

            isQueryDialogVisible.value = true;
        };

        // é—œé–‰æŸ¥è©¢å°è©±æ¡†
        const closeQueryDialog = () => {
            isQueryDialogVisible.value = false;
        };

        // é—œé–‰çµæœåˆ—è¡¨
        const closeResultList = () => {
            isResultListVisible.value = false;
            queryResults.value = [];
        };

        // é–‹å•Ÿåº§æ¨™æŸ¥è©¢å°è©±æ¡†
        const openCoordinateDialog = () => {
            isCoordinateDialogVisible.value = true;
            coordinateParams.x = '';
            coordinateParams.y = '';
            coordinateParams.coordSystem = 'TWD97';
        };

        // é—œé–‰åº§æ¨™æŸ¥è©¢å°è©±æ¡†
        const closeCoordinateDialog = () => {
            isCoordinateDialogVisible.value = false;
        };

        // é–‹å•Ÿå°èˆªç›®æ¨™å°è©±æ¡†
        const openNavigationDialog = () => {
            console.log("Opening navigation dialog");
            console.log("window.navigationTargetsData:", window.navigationTargetsData);
            console.log("navigationTargets.value:", navigationTargets.value);

            if (!window.navigationTargetsData || window.navigationTargetsData.length === 0) {
                snackbarText.value = "å°šç„¡å°èˆªç›®æ¨™ï¼Œè«‹å…ˆåŸ·è¡ŒæŸ¥è©¢";
                showSnackbar.value = true;
                if (snackbarTimer) clearTimeout(snackbarTimer);
                snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 3000);
                return;
            }

            // åŒæ­¥åˆ° Vue ref ä»¥é¡¯ç¤ºåœ¨ UI
            navigationTargets.value = [...window.navigationTargetsData];
            console.log("Updated navigationTargets.value to:", navigationTargets.value);
            isNavigationDialogVisible.value = true;
        };

        // é—œé–‰å°èˆªç›®æ¨™å°è©±æ¡†
        const closeNavigationDialog = () => {
            isNavigationDialogVisible.value = false;
        };

        // å°èˆªåˆ°ç›®æ¨™ï¼ˆå‘¼å« Google Mapsï¼‰
        const navigateToTarget = (target) => {
            if (window.Android && window.Android.navigateToLocation) {
                window.Android.navigateToLocation(target.latitude, target.longitude, target.name);
                closeNavigationDialog();
            } else {
                console.log("Navigation to:", target);
                snackbarText.value = `å°èˆªåˆ°: ${target.name}`;
                showSnackbar.value = true;
                if (snackbarTimer) clearTimeout(snackbarTimer);
                snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 3000);
            }
        };

        // æŠ“å–åœ°åœ–ç•«é¢
        const captureMapScreen = async () => {
            if (!view) {
                console.error("View not initialized");
                snackbarText.value = "åœ°åœ–å°šæœªåˆå§‹åŒ–";
                showSnackbar.value = true;
                if (snackbarTimer) clearTimeout(snackbarTimer);
                snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 3000);
                return;
            }

            try {
                console.log("Capturing map screenshot...");

                // å…ˆé—œé–‰æ‰€æœ‰é¸å–®
                closeAll();

                // å»¶é² 500ms ç­‰å¾…é¸å–®å‹•ç•«å®Œæˆå¾Œå†æˆªåœ–
                setTimeout(async () => {
                    try {
                        console.log("Calling high-res view.takeScreenshot...");

                        // ä½¿ç”¨å¯¦é«”åƒç´ ï¼Œæé«˜ç•«è³ª
                        const dpr = window.devicePixelRatio || 1;
                        console.log("Device pixel ratio:", dpr);

                        // ä½¿ç”¨ ArcGIS API æˆªåœ–ï¼Œä¹˜ä»¥ devicePixelRatio ä»¥ç²å¾—æ›´é«˜è§£æåº¦
                        const screenshot = await view.takeScreenshot({
                            format: 'png',
                            quality: 100,
                            width: view.width * dpr,
                            height: view.height * dpr
                        });

                        console.log("Screenshot captured with high resolution");

                        // å°‡å®Œæ•´çš„ dataUrl å‚³çµ¦ Android
                        const base64Data = screenshot.dataUrl.split(',')[1];
                        console.log("Sending base64 to Android, length:", base64Data.length);

                        if (window.Android && window.Android.saveMapScreenshot) {
                            window.Android.saveMapScreenshot(base64Data);
                        } else {
                            console.error("Android.saveMapScreenshot not available");
                            snackbarText.value = "ç„¡æ³•ä¿å­˜åœ–ç‰‡ï¼šAndroid æ¥å£æœªå°±ç·’";
                            showSnackbar.value = true;
                            if (snackbarTimer) clearTimeout(snackbarTimer);
                            snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 3000);
                        }

                    } catch (err) {
                        console.error("Screenshot capture error:", err);
                        snackbarText.value = "æˆªåœ–å¤±æ•—: " + err.message;
                        showSnackbar.value = true;
                        if (snackbarTimer) clearTimeout(snackbarTimer);
                        snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 3000);
                    }
                }, 500);

            } catch (error) {
                console.error("Screenshot error:", error);
                snackbarText.value = "æˆªåœ–å¤±æ•—: " + error.message;
                showSnackbar.value = true;
                if (snackbarTimer) clearTimeout(snackbarTimer);
                snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 3000);
            }
        };

        // ===== ç¹ªåœ–åŠŸèƒ½ =====

        // é‡æ–°è¨»å†Šåº§æ¨™é¡¯ç¤ºäº‹ä»¶
        const registerCoordinateClickHandler = () => {
            if (coordinateClickHandler) {
                return; // å·²ç¶“è¨»å†Šéäº†
            }

            coordinateClickHandler = view.on("click", async (evt) => {
                // å¦‚æœæ­£åœ¨ç¹ªåœ–ï¼Œä¸è™•ç†åº§æ¨™é¡¯ç¤º
                if (isDrawToolbarVisible.value) {
                    console.log("Drawing mode active, skipping coordinate display");
                    return;
                }

                // å¦‚æœé›»æ¡¿æ¸…å–®æˆ–çºœç·šè¡¨å–®é¡¯ç¤ºä¸­ï¼Œä¸è™•ç†åº§æ¨™é¡¯ç¤º
                if (poleListVisible.value || cableFormVisible.value) {
                    console.log("Cable crossing dialog active, skipping coordinate display");
                    return;
                }

                // æª¢æŸ¥æ˜¯å¦é»åˆ°æ–½å·¥é»åœ–å±¤
                const hitResponse = await view.hitTest(evt);
                if (hitResponse.results.length > 0) {
                    for (let result of hitResponse.results) {
                        if (result.graphic && result.graphic.layer &&
                            (result.graphic.layer.title === 'å°åŒ—å¸‚æ–½å·¥ä½ç½®' ||
                             result.graphic.layer.title === 'æ–°åŒ—å¸‚æ–½å·¥ä½ç½®' ||
                             result.graphic.layer.title === 'æ¡ƒåœ’å¸‚æ–½å·¥ä½ç½®')) {
                            console.log("é»åˆ°æ–½å·¥é»ï¼Œä¸é¡¯ç¤ºåº§æ¨™");
                            return;
                        }
                    }
                }

                try {
                    console.log("Map clicked!");
                    console.log("evt.mapPoint:", evt.mapPoint);
                    console.log("evt.mapPoint.spatialReference:", evt.mapPoint.spatialReference);

                    let lon, lat;

                    if (evt.mapPoint.spatialReference.wkid === 4326 || evt.mapPoint.spatialReference.latestWkid === 4326) {
                        lon = evt.mapPoint.longitude || evt.mapPoint.x;
                        lat = evt.mapPoint.latitude || evt.mapPoint.y;
                    } else {
                        try {
                            if (!projectionModule.isLoaded()) {
                                await projectionModule.load();
                            }
                            const wgsPoint = await projectionModule.project(evt.mapPoint, { wkid: 4326 });
                            if (wgsPoint) {
                                lon = wgsPoint.longitude || wgsPoint.x;
                                lat = wgsPoint.latitude || wgsPoint.y;
                            }
                        } catch (projErr) {
                            console.error("Failed to convert to WGS84:", projErr);
                        }
                    }

                    console.log("Extracted lon/lat:", lon, lat);

                    if (lon && lat) {
                        const lonF = lon.toFixed(6);
                        const latF = lat.toFixed(6);

                        try {
                            if (!projectionModule.isLoaded()) {
                                await projectionModule.load();
                            }
                            const twdPoint = await projectionModule.project(evt.mapPoint, { wkid: 3826 });
                            if (twdPoint) {
                                const twdX = twdPoint.x.toFixed(2);
                                const twdY = twdPoint.y.toFixed(2);
                                snackbarText.value = `WGS84: ${latF}, ${lonF}\\nTWD97: ${twdX}, ${twdY}`;
                            } else {
                                snackbarText.value = `WGS84: ${latF}, ${lonF}`;
                            }
                        } catch (twdErr) {
                            console.error("Failed to convert to TWD97:", twdErr);
                            snackbarText.value = `WGS84: ${latF}, ${lonF}`;
                        }

                        showSnackbar.value = true;
                        if (snackbarTimer) clearTimeout(snackbarTimer);
                        snackbarTimer = setTimeout(() => {
                            showSnackbar.value = false;
                        }, 3000);
                    } else {
                        console.error("Could not extract coordinates from mapPoint");
                    }
                } catch (err) {
                    console.error("Click handling error:", err);
                }
            });

            console.log("Coordinate click handler registered");
        };

        // é–‹å•Ÿç¹ªåœ–å·¥å…·åˆ—
        const openDrawToolbar = async () => {
            console.log("Opening draw toolbar");

            // è¼‰å…¥å¿…è¦çš„ ArcGIS æ¨¡çµ„
            if (!GraphicsLayer) {
                await new Promise(resolve => {
                    require([
    "esri/layers/GraphicsLayer",
    "esri/Graphic",
    "esri/geometry/support/geodesicUtils",
    "esri/geometry/Point",
    "esri/geometry/Multipoint",
    "esri/geometry/Polyline",
    "esri/geometry/Polygon",
    "esri/geometry/projection",
], function(GraphicsLayerClass, GraphicClass, geodesicUtilsModule, PointClass, MultipointClass, PolylineClass, PolygonClass, projection) {
    GraphicsLayer = GraphicsLayerClass;
    window.Graphic = GraphicClass;
    window.geodesicUtils = geodesicUtilsModule;
    window.Point = PointClass;
    window.Multipoint = MultipointClass;
    window.Polyline = PolylineClass;
    window.Polygon = PolygonClass;
    window.PointClass = PointClass;
    window.MultipointClass = MultipointClass;
    window.PolylineClass = PolylineClass;
    window.PolygonClass = PolygonClass;
    console.log("Drawing modules loaded successfully");
    resolve();
});
                });
            }

            // å‰µå»ºç¹ªåœ–åœ–å±¤
            if (!sketchLayer) {
                sketchLayer = new GraphicsLayer({ title: "ç¹ªåœ–åœ–å±¤" });
                map.add(sketchLayer);
            }
            const constructionGeomLayer = new GraphicsLayer();
            map.add(constructionGeomLayer);

            // å‰µå»ºæ¸¬é‡æ¨™ç±¤åœ–å±¤
            if (!measurementLayer) {
                measurementLayer = new GraphicsLayer({ title: "æ¸¬é‡æ¨™ç±¤" });
                map.add(measurementLayer);
            }

            isDrawToolbarVisible.value = true;
        };

        // ç¹ªåœ–ç‹€æ…‹è®Šæ•¸
        let clickHandler = null;
        let doubleClickHandler = null;
        let tempPoints = [];
        let tempGraphic = null;
        let tempLabel = null;
        let isDrawing = false;

        // é¸æ“‡ç¹ªåœ–å·¥å…·
        const selectDrawTool = (tool) => {
            console.log("===== selectDrawTool called =====");
            console.log("Tool:", tool);
            console.log("isDrawToolbarVisible:", isDrawToolbarVisible.value);

            // ç§»é™¤åº§æ¨™é¡¯ç¤ºäº‹ä»¶
            if (coordinateClickHandler) {
                coordinateClickHandler.remove();
                coordinateClickHandler = null;
                console.log("Coordinate click handler removed");
            }

            // æ¸…é™¤èˆŠçš„ç¹ªåœ–ç‹€æ…‹
            cleanupDrawing();

            currentDrawTool.value = tool;
            isDrawing = false;
            tempPoints = [];

            // ç§»é™¤èˆŠçš„äº‹ä»¶ç›£è½
            if (clickHandler) {
                clickHandler.remove();
                clickHandler = null;
            }
            if (doubleClickHandler) {
                doubleClickHandler.remove();
                doubleClickHandler = null;
            }

            // è¨­ç½®æ–°çš„äº‹ä»¶ç›£è½
            if (tool === 'point') {
                // ç•«é»ï¼šå–®æ“Šå³å®Œæˆ
                clickHandler = view.on("click", (event) => {
                    event.stopPropagation();

                    console.log("Point click event triggered");

                    const point = event.mapPoint;

                    const pointGraphic = new window.Graphic({
                        geometry: point,
                        symbol: {
                            type: "simple-marker",
                            color: [255, 0, 0],
                            size: "12px",
                            outline: {
                                color: [255, 255, 255],
                                width: 2
                            }
                        }
                    });

                    sketchLayer.add(pointGraphic);
                    saveDrawingState();

                    console.log("Point added");

                    snackbarText.value = "é»å·²æ–°å¢";
                    showSnackbar.value = true;
                    if (snackbarTimer) clearTimeout(snackbarTimer);
                    snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 1500);
                });

            } else if (tool === 'polyline') {
                // ç•«ç·šï¼šå–®æ“Šæ·»åŠ é»ï¼Œé›™æ“Šå®Œæˆ
                clickHandler = view.on("click", (event) => {
                    event.stopPropagation();

                    console.log("Polyline click event triggered, points:", tempPoints.length);

                    if (!isDrawing) {
                        isDrawing = true;
                        tempPoints = [];
                        console.log("é–‹å§‹ç•«ç·š");

                        snackbarText.value = "é–‹å§‹ç•«ç·šï¼Œé›™æ“Šå®Œæˆ";
                        showSnackbar.value = true;
                        if (snackbarTimer) clearTimeout(snackbarTimer);
                        snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 2000);
                    }

                    tempPoints.push([event.mapPoint.x, event.mapPoint.y]);
                    console.log("ç·šæ¢é»æ•¸:", tempPoints.length);

                    // éœ€è¦è‡³å°‘2å€‹é»æ‰èƒ½ç•«ç·š
                    if (tempPoints.length >= 2) {
                        // ç§»é™¤èˆŠçš„è‡¨æ™‚ç·š
                        if (tempGraphic) {
                            sketchLayer.remove(tempGraphic);
                        }
                        if (tempLabel) {
                            measurementLayer.remove(tempLabel);
                        }

                        // å‰µå»ºæ–°çš„è‡¨æ™‚ç·š
                        const polyline = new window.Polyline({
                            paths: [tempPoints],
                            spatialReference: view.spatialReference
                        });

                        tempGraphic = new window.Graphic({
                            geometry: polyline,
                            symbol: {
                                type: "simple-line",
                                color: [255, 0, 0],
                                width: 3
                            }
                        });

                        sketchLayer.add(tempGraphic);

                        // è¨ˆç®—ä¸¦é¡¯ç¤ºé•·åº¦ï¼ˆä½¿ç”¨ç°¡å–®è·é›¢è¨ˆç®—ï¼‰
                        let totalLength = 0;
                        for (let i = 1; i < tempPoints.length; i++) {
                            const dx = tempPoints[i][0] - tempPoints[i-1][0];
                            const dy = tempPoints[i][1] - tempPoints[i-1][1];
                            totalLength += Math.sqrt(dx * dx + dy * dy);
                        }

                        const lengthText = totalLength >= 1000
                            ? `${(totalLength / 1000).toFixed(2)} km`
                            : `${totalLength.toFixed(2)} m`;

                        const center = polyline.extent.center;

                        const textSymbol = {
                            type: "text",
                            color: "white",
                            haloColor: "black",
                            haloSize: "2px",
                            text: lengthText,
                            font: {
                                size: 14,
                                family: "sans-serif",
                                weight: "bold"
                            }
                        };

                        tempLabel = new window.Graphic({
                            geometry: center,
                            symbol: textSymbol
                        });

                        measurementLayer.add(tempLabel);
                    }
                });

                // é›™æ“Šå®Œæˆç·šæ¢
                doubleClickHandler = view.on("double-click", (event) => {
                    event.stopPropagation();

                    console.log("Polyline double-click, isDrawing:", isDrawing, "points:", tempPoints.length);

                    if (isDrawing && tempPoints.length >= 2) {
                        console.log("ç·šæ¢å®Œæˆï¼Œé»æ•¸:", tempPoints.length);

                        // è‡¨æ™‚åœ–å½¢å·²ç¶“åœ¨åœ–å±¤ä¸Šï¼Œç›´æ¥ä¿å­˜ç‹€æ…‹
                        saveDrawingState();

                        // é‡ç½®ç‹€æ…‹
                        isDrawing = false;
                        tempPoints = [];
                        tempGraphic = null;
                        tempLabel = null;

                        snackbarText.value = "ç·šæ¢å·²å®Œæˆ";
                        showSnackbar.value = true;
                        if (snackbarTimer) clearTimeout(snackbarTimer);
                        snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 1500);
                    }
                });

            } else if (tool === 'polygon') {
                // ç•«é¢ï¼šå–®æ“Šæ·»åŠ é»ï¼Œé›™æ“Šå®Œæˆ
                clickHandler = view.on("click", (event) => {
                    event.stopPropagation();

                    console.log("Polygon click event triggered, points:", tempPoints.length);

                    if (!isDrawing) {
                        isDrawing = true;
                        tempPoints = [];
                        console.log("é–‹å§‹ç•«é¢");

                        snackbarText.value = "é–‹å§‹ç•«é¢ï¼Œé›™æ“Šå®Œæˆ";
                        showSnackbar.value = true;
                        if (snackbarTimer) clearTimeout(snackbarTimer);
                        snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 2000);
                    }

                    tempPoints.push([event.mapPoint.x, event.mapPoint.y]);
                    console.log("é¢çš„é»æ•¸:", tempPoints.length);

                    // éœ€è¦è‡³å°‘3å€‹é»æ‰èƒ½ç•«é¢
                    if (tempPoints.length >= 3) {
                        // ç§»é™¤èˆŠçš„è‡¨æ™‚é¢
                        if (tempGraphic) {
                            sketchLayer.remove(tempGraphic);
                        }
                        if (tempLabel) {
                            measurementLayer.remove(tempLabel);
                        }

                        // å‰µå»ºæ–°çš„è‡¨æ™‚é¢
                        const polygon = new window.Polygon({
                            rings: [tempPoints],
                            spatialReference: view.spatialReference
                        });

                        tempGraphic = new window.Graphic({
                            geometry: polygon,
                            symbol: {
                                type: "simple-fill",
                                color: [255, 0, 0, 0.3],
                                outline: {
                                    color: [255, 0, 0],
                                    width: 2
                                }
                            }
                        });

                        sketchLayer.add(tempGraphic);

                        // è¨ˆç®—ä¸¦é¡¯ç¤ºé¢ç©ï¼ˆä½¿ç”¨ Shoelace å…¬å¼ï¼‰
                        let area = 0;
                        for (let i = 0; i < tempPoints.length; i++) {
                            const j = (i + 1) % tempPoints.length;
                            area += tempPoints[i][0] * tempPoints[j][1];
                            area -= tempPoints[j][0] * tempPoints[i][1];
                        }
                        area = Math.abs(area / 2);

                        const areaText = area >= 10000
                            ? `${(area / 10000).toFixed(2)} å…¬é ƒ`
                            : `${area.toFixed(2)} mÂ²`;

                        const center = polygon.centroid;

                        const textSymbol = {
                            type: "text",
                            color: "white",
                            haloColor: "black",
                            haloSize: "2px",
                            text: areaText,
                            font: {
                                size: 14,
                                family: "sans-serif",
                                weight: "bold"
                            }
                        };

                        tempLabel = new window.Graphic({
                            geometry: center,
                            symbol: textSymbol
                        });

                        measurementLayer.add(tempLabel);
                    }
                });

                // é›™æ“Šå®Œæˆé¢
                doubleClickHandler = view.on("double-click", (event) => {
                    event.stopPropagation();

                    console.log("Polygon double-click, isDrawing:", isDrawing, "points:", tempPoints.length);

                    if (isDrawing && tempPoints.length >= 3) {
                        console.log("é¢å®Œæˆï¼Œé»æ•¸:", tempPoints.length);

                        // è‡¨æ™‚åœ–å½¢å·²ç¶“åœ¨åœ–å±¤ä¸Šï¼Œç›´æ¥ä¿å­˜ç‹€æ…‹
                        saveDrawingState();

                        // é‡ç½®ç‹€æ…‹
                        isDrawing = false;
                        tempPoints = [];
                        tempGraphic = null;
                        tempLabel = null;

                        snackbarText.value = "é¢å·²å®Œæˆ";
                        showSnackbar.value = true;
                        if (snackbarTimer) clearTimeout(snackbarTimer);
                        snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 1500);
                    }
                });
            }
        };

        // æ¸…ç†ç¹ªåœ–ç‹€æ…‹
        const cleanupDrawing = () => {
            if (tempGraphic) {
                sketchLayer.remove(tempGraphic);
                tempGraphic = null;
            }
            if (tempLabel) {
                measurementLayer.remove(tempLabel);
                tempLabel = null;
            }
            isDrawing = false;
            tempPoints = [];
        };

        // ä¿å­˜ç¹ªåœ–ç‹€æ…‹
        const saveDrawingState = () => {
            if (!sketchLayer) return;

            const currentState = {
                graphics: sketchLayer.graphics.items.map(g => g.clone()),
                labels: measurementLayer.graphics.items.map(g => g.clone())
            };

            drawHistory.past.push(currentState);
            drawHistory.future = []; // æ¸…ç©º future

            console.log("Drawing state saved, history length:", drawHistory.past.length);
        };

        // å›ä¸Šä¸€æ­¥
        const undoDrawing = () => {
            if (drawHistory.past.length === 0) {
                console.log("No more undo");
                snackbarText.value = "ç„¡æ³•å¾©åŸ";
                showSnackbar.value = true;
                if (snackbarTimer) clearTimeout(snackbarTimer);
                snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 1500);
                return;
            }

            // æ¸…ç†ç•¶å‰ç¹ªåœ–ç‹€æ…‹
            cleanupDrawing();

            // ä¿å­˜ç•¶å‰ç‹€æ…‹åˆ° future
            const currentState = {
                graphics: sketchLayer.graphics.items.map(g => g.clone()),
                labels: measurementLayer.graphics.items.map(g => g.clone())
            };
            drawHistory.future.push(currentState);

            // æ¢å¾©ä¸Šä¸€å€‹ç‹€æ…‹
            const previousState = drawHistory.past.pop();
            sketchLayer.removeAll();
            measurementLayer.removeAll();

            previousState.graphics.forEach(g => {
                sketchLayer.add(g.clone());
            });

            previousState.labels.forEach(g => {
                measurementLayer.add(g.clone());
            });

            console.log("Undo, history length:", drawHistory.past.length);

            snackbarText.value = "å·²å¾©åŸ";
            showSnackbar.value = true;
            if (snackbarTimer) clearTimeout(snackbarTimer);
            snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 1500);
        };

        // ä¸‹ä¸€æ­¥
        const redoDrawing = () => {
            if (drawHistory.future.length === 0) {
                console.log("No more redo");
                snackbarText.value = "ç„¡æ³•é‡åš";
                showSnackbar.value = true;
                if (snackbarTimer) clearTimeout(snackbarTimer);
                snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 1500);
                return;
            }

            // æ¸…ç†ç•¶å‰ç¹ªåœ–ç‹€æ…‹
            cleanupDrawing();

            // ä¿å­˜ç•¶å‰ç‹€æ…‹åˆ° past
            const currentState = {
                graphics: sketchLayer.graphics.items.map(g => g.clone()),
                labels: measurementLayer.graphics.items.map(g => g.clone())
            };
            drawHistory.past.push(currentState);

            // æ¢å¾© future ä¸­çš„ç‹€æ…‹
            const nextState = drawHistory.future.pop();
            sketchLayer.removeAll();
            measurementLayer.removeAll();

            nextState.graphics.forEach(g => {
                sketchLayer.add(g.clone());
            });

            nextState.labels.forEach(g => {
                measurementLayer.add(g.clone());
            });

            console.log("Redo, history length:", drawHistory.future.length);

            snackbarText.value = "å·²é‡åš";
            showSnackbar.value = true;
            if (snackbarTimer) clearTimeout(snackbarTimer);
            snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 1500);
        };

        // æ¸…é™¤ç¹ªåœ–
        const clearDrawing = () => {
            cleanupDrawing();

            if (sketchLayer) {
                sketchLayer.removeAll();
            }
            if (measurementLayer) {
                measurementLayer.removeAll();
            }

            drawHistory.past = [];
            drawHistory.future = [];

            console.log("Drawing cleared");

            snackbarText.value = "å·²æ¸…é™¤ç¹ªåœ–";
            showSnackbar.value = true;
            if (snackbarTimer) clearTimeout(snackbarTimer);
            snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 2000);
        };

        // è¼¸å‡ºç¹ªåœ–ï¼ˆæˆªåœ–ï¼‰
        const exportDrawing = () => {
            console.log("Export drawing");
            captureMapScreen();
        };

        // é—œé–‰ç¹ªåœ–å·¥å…·åˆ—
        const closeDrawToolbar = () => {
            console.log("Closing draw toolbar");

            // æ¸…ç†ç¹ªåœ–ç‹€æ…‹
            cleanupDrawing();

            // ç§»é™¤äº‹ä»¶ç›£è½
            if (clickHandler) {
                clickHandler.remove();
                clickHandler = null;
            }
            if (doubleClickHandler) {
                doubleClickHandler.remove();
                doubleClickHandler = null;
            }

            // æ¸…é™¤æ‰€æœ‰ç¹ªåœ–
            if (sketchLayer) {
                sketchLayer.removeAll();
            }
            if (measurementLayer) {
                measurementLayer.removeAll();
            }

            drawHistory.past = [];
            drawHistory.future = [];
            currentDrawTool.value = null;
            isDrawToolbarVisible.value = false;

            // é‡æ–°è¨»å†Šåº§æ¨™é¡¯ç¤ºäº‹ä»¶
            registerCoordinateClickHandler();
        };

        // ===== æ‹ç…§åŠ è¨»åŠŸèƒ½ =====

        // é–‹å•Ÿæ‹ç…§å°è©±æ¡†
        const openPhotoDialog = () => {
            console.log("Opening photo dialog");
            photoNote.value = '';
            photoCoordType.value = 'wgs84';
            isPhotoDialogVisible.value = true;
        };

        // é—œé–‰æ‹ç…§å°è©±æ¡†
        const closePhotoDialog = () => {
            console.log("Closing photo dialog");
            isPhotoDialogVisible.value = false;
        };

        // é–‹å•Ÿç›¸æ©Ÿæ‹ç…§
        const openCamera = async () => {
            console.log("Opening camera");

            // ç²å–ç•¶å‰ä½ç½®åº§æ¨™
            let currentLat = null;
            let currentLon = null;

            if (locateWidget && locateWidget.viewModel && locateWidget.viewModel.position) {
                const pos = locateWidget.viewModel.position.coords;
                currentLat = pos.latitude;
                currentLon = pos.longitude;
            } else if (view && view.center) {
                // å¦‚æœæ²’æœ‰ GPS ä½ç½®ï¼Œä½¿ç”¨åœ°åœ–ä¸­å¿ƒé»
                const center = view.center;
                if (center.spatialReference.wkid === 4326 || center.spatialReference.latestWkid === 4326) {
                    currentLon = center.longitude || center.x;
                    currentLat = center.latitude || center.y;
                } else {
                    // è½‰æ›ç‚º WGS84
                    try {
                        if (!projectionModule.isLoaded()) {
                            await projectionModule.load();
                        }
                        const wgsPoint = await projectionModule.project(center, { wkid: 4326 });
                        if (wgsPoint) {
                            currentLon = wgsPoint.longitude || wgsPoint.x;
                            currentLat = wgsPoint.latitude || wgsPoint.y;
                        }
                    } catch (err) {
                        console.error("Failed to convert coordinates:", err);
                    }
                }
            }

            if (!currentLat || !currentLon) {
                snackbarText.value = "ç„¡æ³•å–å¾—åº§æ¨™ä½ç½®";
                showSnackbar.value = true;
                if (snackbarTimer) clearTimeout(snackbarTimer);
                snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 3000);
                return;
            }

            console.log("Current position:", currentLat, currentLon);

            // æº–å‚™åº§æ¨™æ–‡å­—
            let coordText = '';

            if (photoCoordType.value === 'wgs84') {
                coordText = `WGS84: ${currentLat.toFixed(6)}, ${currentLon.toFixed(6)}`;
            } else if (photoCoordType.value === 'twd97') {
                // è½‰æ›ç‚º TWD97
                try {
                    if (!projectionModule.isLoaded()) {
                        await projectionModule.load();
                    }

                    const wgs84Point = {
                        type: "point",
                        longitude: currentLon,
                        latitude: currentLat,
                        spatialReference: { wkid: 4326 }
                    };

                    const twdPoint = await projectionModule.project(wgs84Point, { wkid: 3826 });
                    if (twdPoint) {
                        const twdX = twdPoint.x.toFixed(2);
                        const twdY = twdPoint.y.toFixed(2);
                        coordText = `TWD97: ${twdX}, ${twdY}`;
                    } else {
                        coordText = `WGS84: ${currentLat.toFixed(6)}, ${currentLon.toFixed(6)}`;
                    }
                } catch (err) {
                    console.error("Failed to convert to TWD97:", err);
                    coordText = `WGS84: ${currentLat.toFixed(6)}, ${currentLon.toFixed(6)}`;
                }
            }

            console.log("Coordinate text:", coordText);
            console.log("Note text:", photoNote.value);

            // èª¿ç”¨ Android ç›¸æ©ŸåŠŸèƒ½
            if (window.Android && window.Android.openCameraWithAnnotation) {
                window.Android.openCameraWithAnnotation(photoNote.value, coordText);
                closePhotoDialog();
            } else {
                console.error("Android.openCameraWithAnnotation not available");
                snackbarText.value = "ç›¸æ©ŸåŠŸèƒ½ä¸å¯ç”¨";
                showSnackbar.value = true;
                if (snackbarTimer) clearTimeout(snackbarTimer);
                snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 3000);
            }
        };

        // ===== å·¡å‹˜æ¨™è¨»åŠŸèƒ½ =====

        let annotationClickHandler = null;
        let tempAnnotationGraphic = null;
        let pendingTextPoint = null;

        // é–‹å•Ÿå·¡å‹˜æ¨™è¨»å·¥å…·åˆ—
        const openAnnotationToolbar = async () => {
            console.log("Opening annotation toolbar");

            // è¼‰å…¥å¿…è¦æ¨¡çµ„ï¼ˆå¦‚æœå°šæœªè¼‰å…¥ï¼‰
            if (!GraphicsLayer) {
                await new Promise(resolve => {
                    require([
                        "esri/layers/GraphicsLayer",
                        "esri/Graphic"
                    ], function(GraphicsLayerClass, GraphicClass) {
                        GraphicsLayer = GraphicsLayerClass;
                        window.Graphic = GraphicClass;
                        resolve();
                    });
                });
            }

            // å‰µå»ºæ¨™è¨»åœ–å±¤
            if (!annotationLayer) {
                annotationLayer = new GraphicsLayer({ title: "æ¨™è¨»åœ–å±¤" });
                map.add(annotationLayer);
            }

            // å…ˆé¡¯ç¤ºå·¥å…·åˆ—
            isAnnotationToolbarVisible.value = true;

            // ä¸å†å¼·åˆ¶åˆ‡æ›è¢å¹•æ–¹å‘ï¼Œä½¿ç”¨ç•¶å‰æ–¹å‘
            // if (window.Android && window.Android.setOrientation) {
            //     window.Android.setOrientation('landscape');
            // }
        };

        // é¸æ“‡æ¨™è¨»å·¥å…·
        const selectAnnotationTool = (tool) => {
            console.log("Select annotation tool:", tool);

            currentAnnotationTool.value = tool;

            // ç§»é™¤èˆŠçš„äº‹ä»¶ç›£è½
            if (annotationClickHandler) {
                annotationClickHandler.remove();
                annotationClickHandler = null;
            }

            // æ¸…é™¤è‡¨æ™‚åœ–å½¢
            if (tempAnnotationGraphic) {
                annotationLayer.remove(tempAnnotationGraphic);
                tempAnnotationGraphic = null;
            }

            // è¨­ç½®æ–°çš„äº‹ä»¶ç›£è½
            if (tool === 'arrow') {
                // ç•«ç®­é ­ï¼šé»å…©æ¬¡
                let startPoint = null;

                annotationClickHandler = view.on("click", (event) => {
                    event.stopPropagation();

                    if (!startPoint) {
                        // ç¬¬ä¸€æ¬¡é»æ“Šï¼šè¨˜éŒ„èµ·é»
                        startPoint = event.mapPoint;
                        console.log("Arrow start point set");

                        snackbarText.value = "è«‹é»æ“Šç®­é ­çµ‚é»";
                        showSnackbar.value = true;
                        if (snackbarTimer) clearTimeout(snackbarTimer);
                        snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 2000);
                    } else {
                        // ç¬¬äºŒæ¬¡é»æ“Šï¼šç¹ªè£½ç®­é ­
                        const endPoint = event.mapPoint;

                        // è¨ˆç®—ç®­é ­è§’åº¦
                        const dx = endPoint.x - startPoint.x;
                        const dy = endPoint.y - startPoint.y;
                        const angle = Math.atan2(dy, dx);
                        const arrowLength = Math.sqrt(dx * dx + dy * dy) * 0.15; // ç®­é ­é•·åº¦ç‚ºç·šæ®µçš„ 15%
                        const arrowAngle = Math.PI / 6; // 30 åº¦

                        // è¨ˆç®—ç®­é ­å…©å€‹å°¾ç¿¼çš„é»
                        const arrowPoint1X = endPoint.x - arrowLength * Math.cos(angle - arrowAngle);
                        const arrowPoint1Y = endPoint.y - arrowLength * Math.sin(angle - arrowAngle);
                        const arrowPoint2X = endPoint.x - arrowLength * Math.cos(angle + arrowAngle);
                        const arrowPoint2Y = endPoint.y - arrowLength * Math.sin(angle + arrowAngle);

                        // å‰µå»ºç®­é ­ç·šæ¢
                        const arrowLine = {
                            type: "polyline",
                            paths: [[
                                [startPoint.x, startPoint.y],
                                [endPoint.x, endPoint.y]
                            ]],
                            spatialReference: view.spatialReference
                        };

                        const lineGraphic = new window.Graphic({
                            geometry: arrowLine,
                            symbol: {
                                type: "simple-line",
                                color: [255, 0, 0],
                                width: 4,
                                style: "solid"
                            }
                        });

                        // å‰µå»ºç®­é ­é ­éƒ¨ï¼ˆå¯¦å¿ƒä¸‰è§’å½¢ï¼‰
                        const arrowHead = {
                            type: "polygon",
                            rings: [[
                                [endPoint.x, endPoint.y],
                                [arrowPoint1X, arrowPoint1Y],
                                [arrowPoint2X, arrowPoint2Y],
                                [endPoint.x, endPoint.y]
                            ]],
                            spatialReference: view.spatialReference
                        };

                        const headGraphic = new window.Graphic({
                            geometry: arrowHead,
                            symbol: {
                                type: "simple-fill",
                                color: [255, 0, 0],
                                outline: {
                                    color: [255, 0, 0],
                                    width: 1
                                }
                            }
                        });

                        annotationLayer.add(lineGraphic);
                        annotationLayer.add(headGraphic);
                        saveAnnotationState();

                        startPoint = null;
                        console.log("Arrow drawn");

                        snackbarText.value = "ç®­é ­å·²æ–°å¢";
                        showSnackbar.value = true;
                        if (snackbarTimer) clearTimeout(snackbarTimer);
                        snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 1500);
                    }
                });

            } else if (tool === 'circle') {
                // ç•«åœ“åœˆï¼šé»å…©æ¬¡
                let centerPoint = null;

                annotationClickHandler = view.on("click", (event) => {
                    event.stopPropagation();

                    if (!centerPoint) {
                        // ç¬¬ä¸€æ¬¡é»æ“Šï¼šè¨˜éŒ„åœ“å¿ƒ
                        centerPoint = event.mapPoint;
                        console.log("Circle center set");

                        snackbarText.value = "è«‹é»æ“Šåœ“çš„é‚Šç·£";
                        showSnackbar.value = true;
                        if (snackbarTimer) clearTimeout(snackbarTimer);
                        snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 2000);
                    } else {
                        // ç¬¬äºŒæ¬¡é»æ“Šï¼šè¨ˆç®—åŠå¾‘ä¸¦ç¹ªè£½åœ“
                        const edgePoint = event.mapPoint;

                        const dx = edgePoint.x - centerPoint.x;
                        const dy = edgePoint.y - centerPoint.y;
                        const radius = Math.sqrt(dx * dx + dy * dy);

                        // å‰µå»ºåœ“å½¢
                        const circleGraphic = new window.Graphic({
                            geometry: {
                                type: "point",
                                x: centerPoint.x,
                                y: centerPoint.y,
                                spatialReference: view.spatialReference
                            },
                            symbol: {
                                type: "simple-marker",
                                style: "circle",
                                color: [255, 0, 0, 0],
                                size: radius * 2 / view.resolution,
                                outline: {
                                    color: [255, 0, 0],
                                    width: 3
                                }
                            }
                        });

                        annotationLayer.add(circleGraphic);
                        saveAnnotationState();

                        centerPoint = null;
                        console.log("Circle drawn");

                        snackbarText.value = "åœ“åœˆå·²æ–°å¢";
                        showSnackbar.value = true;
                        if (snackbarTimer) clearTimeout(snackbarTimer);
                        snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 1500);
                    }
                });

            } else if (tool === 'text') {
                // æ¨™è¨˜æ–‡å­—ï¼šé»æ“Šä½ç½®å¾Œè¼¸å…¥æ–‡å­—
                annotationClickHandler = view.on("click", (event) => {
                    event.stopPropagation();

                    pendingTextPoint = event.mapPoint;
                    annotationText.value = '';
                    isTextInputDialogVisible.value = true;
                });
            }
        };

        // é—œé–‰æ–‡å­—è¼¸å…¥å°è©±æ¡†
        const closeTextInputDialog = () => {
            isTextInputDialogVisible.value = false;
            pendingTextPoint = null;
        };

        // ç¢ºèªæ–‡å­—è¼¸å…¥
        const confirmTextInput = () => {
            if (!annotationText.value || !pendingTextPoint) {
                closeTextInputDialog();
                return;
            }

            // å‰µå»ºæ–‡å­—åœ–å½¢
            const textGraphic = new window.Graphic({
                geometry: pendingTextPoint,
                symbol: {
                    type: "text",
                    color: [255, 0, 0],
                    text: annotationText.value,
                    font: {
                        size: 50,
                        family: "sans-serif",
                        weight: "bold"
                    }
                }
            });

            annotationLayer.add(textGraphic);
            saveAnnotationState();

            console.log("Text added:", annotationText.value);

            snackbarText.value = "æ–‡å­—å·²æ–°å¢";
            showSnackbar.value = true;
            if (snackbarTimer) clearTimeout(snackbarTimer);
            snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 1500);

            closeTextInputDialog();
        };

        // ä¿å­˜æ¨™è¨»ç‹€æ…‹
        const saveAnnotationState = () => {
            if (!annotationLayer) return;

            const currentState = annotationLayer.graphics.items.map(g => g.clone());
            annotationHistory.past.push(currentState);
            annotationHistory.future = [];

            console.log("Annotation state saved, history length:", annotationHistory.past.length);
        };

        // å›ä¸Šä¸€æ­¥
        const undoAnnotation = () => {
            if (annotationHistory.past.length === 0) {
                console.log("No more undo");
                snackbarText.value = "ç„¡æ³•å¾©åŸ";
                showSnackbar.value = true;
                if (snackbarTimer) clearTimeout(snackbarTimer);
                snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 1500);
                return;
            }

            // ä¿å­˜ç•¶å‰ç‹€æ…‹åˆ° future
            const currentState = annotationLayer.graphics.items.map(g => g.clone());
            annotationHistory.future.push(currentState);

            // æ¢å¾©ä¸Šä¸€å€‹ç‹€æ…‹
            const previousState = annotationHistory.past.pop();
            annotationLayer.removeAll();
            previousState.forEach(g => annotationLayer.add(g.clone()));

            console.log("Undo, history length:", annotationHistory.past.length);

            snackbarText.value = "å·²å¾©åŸ";
            showSnackbar.value = true;
            if (snackbarTimer) clearTimeout(snackbarTimer);
            snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 1500);
        };

        // ä¸‹ä¸€æ­¥
        const redoAnnotation = () => {
            if (annotationHistory.future.length === 0) {
                console.log("No more redo");
                snackbarText.value = "ç„¡æ³•é‡åš";
                showSnackbar.value = true;
                if (snackbarTimer) clearTimeout(snackbarTimer);
                snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 1500);
                return;
            }

            // ä¿å­˜ç•¶å‰ç‹€æ…‹åˆ° past
            const currentState = annotationLayer.graphics.items.map(g => g.clone());
            annotationHistory.past.push(currentState);

            // æ¢å¾© future ä¸­çš„ç‹€æ…‹
            const nextState = annotationHistory.future.pop();
            annotationLayer.removeAll();
            nextState.forEach(g => annotationLayer.add(g.clone()));

            console.log("Redo, history length:", annotationHistory.future.length);

            snackbarText.value = "å·²é‡åš";
            showSnackbar.value = true;
            if (snackbarTimer) clearTimeout(snackbarTimer);
            snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 1500);
        };

        // æ¸…é™¤æ¨™è¨»
        const clearAnnotation = () => {
            if (annotationLayer) {
                annotationLayer.removeAll();
            }

            annotationHistory.past = [];
            annotationHistory.future = [];
            qrCodePoint = null;

            console.log("Annotation cleared");

            snackbarText.value = "å·²æ¸…é™¤æ¨™è¨»";
            showSnackbar.value = true;
            if (snackbarTimer) clearTimeout(snackbarTimer);
            snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 2000);
        };

        // æ‰“é–‹å·¥ä½œæ–‡å­—å°è©±æ¡†
        const openWorkTextDialog = () => {
            isWorkTextDialogVisible.value = true;
        };

        // é—œé–‰å·¥ä½œæ–‡å­—å°è©±æ¡†
        const closeWorkTextDialog = () => {
            isWorkTextDialogVisible.value = false;
        };

        // ç¢ºèªå·¥ä½œæ–‡å­—
        const confirmWorkText = () => {
            console.log("Work text set:", workText.value);

            snackbarText.value = workText.value ? "å·¥ä½œæ–‡å­—å·²è¨­å®š" : "å·¥ä½œæ–‡å­—å·²æ¸…é™¤";
            showSnackbar.value = true;
            if (snackbarTimer) clearTimeout(snackbarTimer);
            snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 2000);

            closeWorkTextDialog();
        };

        // æ–°å¢ QR Code
        const addQRCode = () => {
            annotationClickHandler = view.on("click", (event) => {
                event.stopPropagation();

                qrCodePoint = event.mapPoint;

                console.log("QR Code point set:", qrCodePoint.latitude, qrCodePoint.longitude);

                snackbarText.value = "QR Code ä½ç½®å·²è¨­å®šï¼Œè¼¸å‡ºæ™‚æœƒåŠ å…¥å·¦ä¸Šè§’";
                showSnackbar.value = true;
                if (snackbarTimer) clearTimeout(snackbarTimer);
                snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 3000);

                // ç§»é™¤äº‹ä»¶ç›£è½
                annotationClickHandler.remove();
                annotationClickHandler = null;
                currentAnnotationTool.value = null;
            });

            snackbarText.value = "è«‹é»æ“Šåœ°åœ–é¸æ“‡ QR Code ä½ç½®";
            showSnackbar.value = true;
            if (snackbarTimer) clearTimeout(snackbarTimer);
            snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 3000);
        };

        // è¼¸å‡ºæ¨™è¨»ç•«é¢
        const exportAnnotation = async () => {
            console.log("Export annotation");

            // å¦‚æœæœ‰ QR Code ä½ç½®ï¼Œç”Ÿæˆ Google è¡—æ™¯ URL ä¸¦å‚³çµ¦ Android
            if (qrCodePoint) {
                let lat, lon;

                if (qrCodePoint.spatialReference.wkid === 4326 || qrCodePoint.spatialReference.latestWkid === 4326) {
                    lat = qrCodePoint.latitude || qrCodePoint.y;
                    lon = qrCodePoint.longitude || qrCodePoint.x;
                } else {
                    try {
                        if (!projectionModule.isLoaded()) {
                            await projectionModule.load();
                        }
                        const wgsPoint = await projectionModule.project(qrCodePoint, { wkid: 4326 });
                        if (wgsPoint) {
                            lat = wgsPoint.latitude || wgsPoint.y;
                            lon = wgsPoint.longitude || wgsPoint.x;
                        }
                    } catch (err) {
                        console.error("Failed to convert QR Code coordinates", err);
                    }
                }

                if (lat && lon) {
                    const streetViewUrl = `https://www.google.com/maps/@?api=1&map_action=pano&viewpoint=${lat},${lon}`;
                    console.log("Street view URL:", streetViewUrl);

                    // é—œé–‰æ‰€æœ‰é¸å–®ä»¥ä¾¿æˆªåœ–
                    closeAll();

                    // ç­‰å¾…ä¸€ä¸‹ç¢ºä¿é¸å–®å·²é—œé–‰
                    setTimeout(async () => {
                        try {
                            const dpr = window.devicePixelRatio || 1;
                            const screenshot = await view.takeScreenshot({
                                format: 'png',
                                quality: 100,
                                width: view.width * dpr,
                                height: view.height * dpr
                            });

                            // å‚³çµ¦ Androidï¼ŒåŒ…å« QR Code URL å’Œå·¥ä½œæ–‡å­—
                            if (window.Android && window.Android.saveScreenshotWithQRCode) {
                                window.Android.saveScreenshotWithQRCode(
                                    screenshot.dataUrl.split(',')[1],
                                    streetViewUrl,
                                    workText.value || ''
                                );
                            } else {
                                console.error("Android.saveScreenshotWithQRCode not available");
                                snackbarText.value = "QR Code åŠŸèƒ½ä¸å¯ç”¨";
                                showSnackbar.value = true;
                                if (snackbarTimer) clearTimeout(snackbarTimer);
                                snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 2000);
                            }
                        } catch (err) {
                            console.error("Screenshot failed:", err);
                            snackbarText.value = "æˆªåœ–å¤±æ•—";
                            showSnackbar.value = true;
                            if (snackbarTimer) clearTimeout(snackbarTimer);
                            snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 2000);
                        }
                    }, 500);

                    return;
                }
            }

            // æ²’æœ‰ QR Codeï¼Œä½¿ç”¨ä¸€èˆ¬æˆªåœ–
            await captureMapScreen();
        };

        // é—œé–‰æ¨™è¨»å·¥å…·åˆ—
        const closeAnnotationToolbar = () => {
            console.log("Closing annotation toolbar");

            // ç§»é™¤äº‹ä»¶ç›£è½
            if (annotationClickHandler) {
                annotationClickHandler.remove();
                annotationClickHandler = null;
            }

            // æ¸…é™¤æ‰€æœ‰æ¨™è¨»
            if (annotationLayer) {
                annotationLayer.removeAll();
            }

            annotationHistory.past = [];
            annotationHistory.future = [];
            currentAnnotationTool.value = null;
            qrCodePoint = null;
            workText.value = ''; // æ¸…é™¤å·¥ä½œæ–‡å­—
            isAnnotationToolbarVisible.value = false;

            // ä¸å†å¼·åˆ¶åˆ‡æ›å›ç›´å‘
            // if (window.Android && window.Android.setOrientation) {
            //     window.Android.setOrientation('portrait');
            // }
        };

        // åŸ·è¡Œåº§æ¨™æŸ¥è©¢
        const executeCoordinateQuery = async () => {
            if (!coordinateParams.x || !coordinateParams.y) {
                snackbarText.value = "è«‹è¼¸å…¥å®Œæ•´çš„ X å’Œ Y åº§æ¨™";
                showSnackbar.value = true;
                if (snackbarTimer) clearTimeout(snackbarTimer);
                snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 3000);
                return;
            }

            closeCoordinateDialog();

            try {
                const x = parseFloat(coordinateParams.x);
                const y = parseFloat(coordinateParams.y);

                if (isNaN(x) || isNaN(y)) {
                    throw new Error("åº§æ¨™æ ¼å¼éŒ¯èª¤ï¼Œè«‹è¼¸å…¥æ•¸å­—");
                }

                if (!view || !PointClass) {
                    throw new Error("åœ°åœ–å°šæœªåˆå§‹åŒ–");
                }

                let targetPoint;
                let wgs84Point;

                if (coordinateParams.coordSystem === 'TWD97') {
                    // TWD97 (EPSG:3826)
                    targetPoint = new PointClass({
                        x: x,
                        y: y,
                        spatialReference: { wkid: 3826 }
                    });

                    // è½‰æ›ç‚º WGS84 ä»¥å„²å­˜å°èˆªç›®æ¨™
                    if (!projectionModule) {
                        console.error("projectionModule is null!");
                    } else if (!projectionModule.isLoaded()) {
                        console.log("Projection not loaded, loading now...");
                        await projectionModule.load();
                    }

                    wgs84Point = await projectionModule.project(targetPoint, { wkid: 4326 });
                    console.log("Converted TWD97 to WGS84:", wgs84Point);
                } else {
                    // WGS84 ç¶“ç·¯åº¦ (EPSG:4326)
                    targetPoint = new PointClass({
                        longitude: x,
                        latitude: y,
                        spatialReference: { wkid: 4326 }
                    });
                    wgs84Point = targetPoint;
                }

                // ç§»é™¤èˆŠçš„æ¨™è¨˜ï¼ˆä¿ç•™å®šä½æ¨™è¨˜ï¼‰
                const graphics = view.graphics.toArray();
                graphics.forEach(g => {
                    if (g !== locationGraphic) {
                        view.graphics.remove(g);
                    }
                });

                // æ·»åŠ åº§æ¨™æ¨™è¨˜
                const coordSymbol = new SimpleMarkerSymbolClass({
                    color: [0, 255, 0, 0.6],
                    outline: {
                        color: [255, 255, 255],
                        width: 3
                    },
                    size: 16
                });

                const coordGraphic = new GraphicClass({
                    geometry: targetPoint,
                    symbol: coordSymbol
                });

                view.graphics.add(coordGraphic);

                // ç¸®æ”¾åˆ°åº§æ¨™ï¼Œæ¯”ä¾‹ 500
                await view.goTo({
                    target: targetPoint,
                    scale: 500
                });

                // === æ–°å¢: ä¿å­˜ç‚ºå°èˆªç›®æ¨™ ===
                if (wgs84Point && (wgs84Point.longitude !== undefined || wgs84Point.x !== undefined)) {
                    // ç¢ºä¿ window.navigationTargetsData å­˜åœ¨
                    if (!window.navigationTargetsData) {
                        window.navigationTargetsData = [];
                        console.log("Initialized window.navigationTargetsData");
                    }

                    // å»ºç«‹å°èˆªç›®æ¨™åç¨±
                    let targetName;
                    if (coordinateParams.coordSystem === 'TWD97') {
                        targetName = `åº§æ¨™ TWD97: ${x.toFixed(2)}, ${y.toFixed(2)}`;
                    } else {
                        targetName = `åº§æ¨™ WGS84: ${x.toFixed(6)}, ${y.toFixed(6)}`;
                    }

                    const navTarget = {
                        name: targetName,
                        longitude: wgs84Point.longitude || wgs84Point.x,
                        latitude: wgs84Point.latitude || wgs84Point.y,
                        timestamp: Date.now()
                    };

                    console.log("Creating coordinate nav target:", navTarget);

                    // é¿å…é‡è¤‡ï¼Œæª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸åŒåç¨±
                    const existingIndex = window.navigationTargetsData.findIndex(t => t.name === targetName);
                    if (existingIndex >= 0) {
                        window.navigationTargetsData.splice(existingIndex, 1);
                        console.log("Removed existing coordinate target");
                    }

                    // æ–°å¢åˆ°åˆ—è¡¨å‰é¢ï¼Œæœ€å¤šä¿ç•™ 20 å€‹
                    window.navigationTargetsData.unshift(navTarget);
                    if (window.navigationTargetsData.length > 20) {
                        window.navigationTargetsData = window.navigationTargetsData.slice(0, 20);
                    }

                    console.log("âœ“ Coordinate navigation target saved to window:", navTarget);
                    console.log("âœ“ Total navigation targets:", window.navigationTargetsData.length);
                }

                snackbarText.value = `å·²å®šä½è‡³åº§æ¨™: ${coordinateParams.coordSystem} (${x.toFixed(2)}, ${y.toFixed(2)})`;
                showSnackbar.value = true;
                if (snackbarTimer) clearTimeout(snackbarTimer);
                snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 3000);

            } catch (error) {
                console.error("Coordinate query error:", error);
                snackbarText.value = "åº§æ¨™æŸ¥è©¢ç™¼ç”ŸéŒ¯èª¤: " + error.message;
                showSnackbar.value = true;
                if (snackbarTimer) clearTimeout(snackbarTimer);
                snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 3000);
            }
        };

        // åŸ·è¡ŒæŸ¥è©¢ï¼ˆé€šç”¨ï¼‰
        const executeQuery = async () => {
            const config = queryConfigs[currentQueryType.value];
            if (!config) {
                snackbarText.value = "æŸ¥è©¢é…ç½®éŒ¯èª¤";
                showSnackbar.value = true;
                if (snackbarTimer) clearTimeout(snackbarTimer);
                snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 3000);
                return;
            }

            // æª¢æŸ¥æ˜¯å¦è‡³å°‘è¼¸å…¥ä¸€å€‹æ¢ä»¶
            const hasInput = config.fields.some(field => queryParams[field.key]);
            if (!hasInput) {
                snackbarText.value = "è«‹è‡³å°‘è¼¸å…¥ä¸€å€‹æŸ¥è©¢æ¢ä»¶";
                showSnackbar.value = true;
                if (snackbarTimer) clearTimeout(snackbarTimer);
                snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 3000);
                return;
            }

            closeQueryDialog();

            try {
                let targetLayerUrl;

                // ç‰¹æ®Šè™•ç†ï¼šbaseDyLayer ç›´æ¥ä½¿ç”¨å‹•æ…‹åº•åœ–
                if (config.layerGroup === 'baseDyLayer') {
                    console.log("Using baseDyLayer for address query");

                    // baseDyLayer æ˜¯å…¨åŸŸè®Šæ•¸ï¼Œç›´æ¥ä½¿ç”¨
                    if (!baseDyLayer) {
                        throw new Error('baseDyLayer å°šæœªåˆå§‹åŒ–');
                    }

                    await baseDyLayer.load();

                    // å¾ baseDyLayer ä¸­æ‰¾åˆ°åœ°å€é»åœ–å±¤
                    targetLayerUrl = findLayerUrl(baseDyLayer, config.layerName);

                    if (!targetLayerUrl) {
                        throw new Error(`åœ¨ baseDyLayer ä¸­æ‰¾ä¸åˆ°${config.layerName}åœ–å±¤`);
                    }
                } else {
                    // ä¸€èˆ¬æŸ¥è©¢ï¼šå¾ layerList æ‰¾åœ–å±¤
                    const targetLayer = layerList.find(l => l.name === config.layerGroup);
                    if (!targetLayer || !targetLayer.url) {
                        throw new Error(`æ‰¾ä¸åˆ°${config.layerGroup}åœ–å±¤`);
                    }

                    // è¼‰å…¥åœ–å±¤ä»¥å–å¾— sublayers
                    const tempLayer = new MapImageLayerClass({
                        url: targetLayer.url,
                        customParameters: { token: appToken }
                    });

                    await tempLayer.load();

                    // ä½¿ç”¨ findLayerUrl æ‰¾åˆ°ç›®æ¨™åœ–å±¤
                    targetLayerUrl = findLayerUrl(tempLayer, config.layerName);

                    if (!targetLayerUrl) {
                        throw new Error(`æ‰¾ä¸åˆ°${config.layerName}åœ–å±¤`);
                    }
                }

                console.log(`${currentQueryType.value} Layer URL:`, targetLayerUrl);

                // å»ºç«‹ FeatureLayer ä¾†åŸ·è¡ŒæŸ¥è©¢
                const queryLayer = new FeatureLayerClass({
                    url: targetLayerUrl,
                    customParameters: { token: appToken }
                });

                // å»ºç«‹æŸ¥è©¢åƒæ•¸
                const query = queryLayer.createQuery();
                query.where = config.buildWhereClause(queryParams);
                query.outFields = ["*"];
                query.returnGeometry = true;

                console.log("Query WHERE clause:", query.where);

                // åŸ·è¡ŒæŸ¥è©¢
                const results = await queryLayer.queryFeatures(query);

                console.log("Query results:", results.features.length, "features found");

                if (results.features.length === 0) {
                    snackbarText.value = "æŸ¥ç„¡è³‡æ–™ï¼Œè«‹ç¢ºèªæ¢ä»¶å¾Œé‡æ–°è¼¸å…¥";
                    showSnackbar.value = true;
                    if (snackbarTimer) clearTimeout(snackbarTimer);
                    snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 3000);
                    return;
                }

                // ç‰¹æ®Šè™•ç†ï¼šå¼•ä¸Šé›»çºœæŸ¥è©¢ - ä½¿ç”¨ checklinein éæ¿¾ä¸¦é¡¯ç¤ºç´…è‰²ç·šæ¢
                if (config.isLineQuery && currentQueryType.value === 'å¼•ä¸Šé›»çºœæŸ¥è©¢') {
                    const targetDEpdesc1 = queryParams.d_epdesc1;
                    if (!targetDEpdesc1) {
                        snackbarText.value = "è«‹è¼¸å…¥èŠ¯ç·šç¯„åœ";
                        showSnackbar.value = true;
                        if (snackbarTimer) clearTimeout(snackbarTimer);
                        snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 3000);
                        return;
                    }

                    console.log("å¼•ä¸Šé›»çºœæŸ¥è©¢ - éæ¿¾èŠ¯ç·šç¯„åœ:", targetDEpdesc1);

                    // ä½¿ç”¨ checklinein éæ¿¾çµæœ
                    const filteredFeatures = results.features.filter(feature => {
                        const dEpdesc1 = feature.attributes.D_EPDESC1 || '';
                        if (!dEpdesc1) return false;

                        try {
                            const isMatch = checklinein(dEpdesc1, targetDEpdesc1);
                            console.log(`æª¢æŸ¥: D_EPDESC1=${dEpdesc1}, ç›®æ¨™=${targetDEpdesc1}, çµæœ=${isMatch}`);
                            return isMatch;
                        } catch (err) {
                            console.error('checklinein error:', err, 'dEpdesc1:', dEpdesc1);
                            return false;
                        }
                    });

                    console.log(`éæ¿¾å¾Œçµæœ: ${filteredFeatures.length} / ${results.features.length}`);

                    if (filteredFeatures.length === 0) {
                        snackbarText.value = "æŸ¥ç„¡ç¬¦åˆèŠ¯ç·šç¯„åœçš„è³‡æ–™";
                        showSnackbar.value = true;
                        if (snackbarTimer) clearTimeout(snackbarTimer);
                        snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 3000);
                        return;
                    }

                    // ç§»é™¤èˆŠçš„åœ–å½¢ï¼ˆä¿ç•™å®šä½æ¨™è¨˜ï¼‰
                    const graphics = view.graphics.toArray();
                    graphics.forEach(g => {
                        if (g !== locationGraphic) {
                            view.graphics.remove(g);
                        }
                    });

                    // éœ€è¦ SimpleLineSymbol
                    let SimpleLineSymbolClass = null;
                    await new Promise(resolve => {
                        require(["esri/symbols/SimpleLineSymbol"], function(SimpleLineSymbol) {
                            SimpleLineSymbolClass = SimpleLineSymbol;
                            resolve();
                        });
                    });

                    // ç¹ªè£½ç´…è‰²ç·šæ¢
                    const redLineSymbol = new SimpleLineSymbolClass({
                        color: [255, 0, 0],
                        width: 3
                    });

                    const lineGraphics = filteredFeatures.map(feature => {
                        return new GraphicClass({
                            geometry: feature.geometry,
                            symbol: redLineSymbol
                        });
                    });

                    lineGraphics.forEach(graphic => {
                        view.graphics.add(graphic);
                    });

                    // è¨ˆç®—æ‰€æœ‰ç·šæ¢çš„ extent ä¸¦ç¸®æ”¾
                    let combinedExtent = null;
                    filteredFeatures.forEach(feature => {
                        if (feature.geometry && feature.geometry.extent) {
                            if (!combinedExtent) {
                                combinedExtent = feature.geometry.extent.clone();
                            } else {
                                combinedExtent = combinedExtent.union(feature.geometry.extent);
                            }
                        }
                    });

                    if (combinedExtent) {
                        await view.goTo(combinedExtent.expand(1.5));
                        console.log("âœ“ ç¸®æ”¾è‡³æ‰€æœ‰å¼•ä¸Šé›»çºœç·šæ¢");
                    }

                    snackbarText.value = `æ‰¾åˆ° ${filteredFeatures.length} ç­†ç¬¦åˆçš„å¼•ä¸Šé›»çºœ`;
                    showSnackbar.value = true;
                    if (snackbarTimer) clearTimeout(snackbarTimer);
                    snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 3000);

                    return; // çµæŸåŸ·è¡Œï¼Œä¸èµ°ä¸€èˆ¬æŸ¥è©¢æµç¨‹
                }

                // ğŸŒŸ æ ¸å¿ƒä¿®æ­£ï¼šä½¿ç”¨ markRaw é¿å… Vue å˜—è©¦å°‡è¤‡é›œçš„ Graphic ç‰©ä»¶è½‰æ›ç‚ºéŸ¿æ‡‰å¼
                queryResults.value = results.features.map(feature => markRaw(feature));

                console.log("Setting query results with markRaw, count:", queryResults.value.length);

                if (results.features.length === 1) {
                    // åªæœ‰ä¸€ç­†ï¼Œç›´æ¥ç¸®æ”¾ï¼ˆä½¿ç”¨åŸå§‹ featureï¼‰
                    console.log("Single result, zooming directly");
                    zoomToResult(results.features[0]);
                } else {
                    // å¤šç­†ï¼Œé¡¯ç¤ºåˆ—è¡¨
                    console.log("Multiple results, showing list");
                    isResultListVisible.value = true;
                }

            } catch (error) {
                console.error("Query error:", error);
                snackbarText.value = "æŸ¥è©¢ç™¼ç”ŸéŒ¯èª¤: " + error.message;
                showSnackbar.value = true;
                if (snackbarTimer) clearTimeout(snackbarTimer);
                snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 3000);
            }
        };

        // ç¸®æ”¾åˆ°æŸ¥è©¢çµæœ
        const zoomToResult = async (feature) => {
            console.log(">>> zoomToResult called with feature:", feature);

            if (!view || !feature || !feature.geometry) {
                console.error("âœ— Invalid feature or geometry");
                return;
            }

            closeResultList();

            try {
                console.log(">>> Removing old graphics...");
                // ç§»é™¤èˆŠçš„é«˜äº®æ¨™è¨˜ï¼ˆä½†ä¿ç•™å®šä½æ¨™è¨˜ï¼‰
                const graphics = view.graphics.toArray();
                graphics.forEach(g => {
                    if (g !== locationGraphic) {
                        view.graphics.remove(g);
                    }
                });

                console.log(">>> Adding highlight graphic...");
                // æ·»åŠ é«˜äº®æ¨™è¨˜
                const highlightSymbol = new SimpleMarkerSymbolClass({
                    color: [255, 0, 0, 0.6],
                    outline: {
                        color: [255, 255, 0],
                        width: 3
                    },
                    size: 16
                });

                const highlightGraphic = new GraphicClass({
                    geometry: feature.geometry,
                    symbol: highlightSymbol
                });

                view.graphics.add(highlightGraphic);

                console.log(">>> Zooming to feature...");
                // ç¸®æ”¾åˆ°è©²ä½ç½®ï¼Œæ¯”ä¾‹ 500
                await view.goTo({
                    target: feature.geometry,
                    scale: 500
                }).then(() => {
                    console.log("âœ“ Zoomed to result");
                }).catch(err => {
                    console.error("âœ— GoTo error:", err);
                });

                console.log(">>> Preparing to display info and save navigation target...");
                console.log(">>> currentQueryType.value:", currentQueryType.value);
                console.log(">>> queryConfigs:", Object.keys(queryConfigs));

                // é¡¯ç¤ºè³‡è¨Šï¼ˆä½¿ç”¨é…ç½®çš„é¡¯ç¤ºæ¬„ä½ï¼‰
                const config = queryConfigs[currentQueryType.value];
                console.log(">>> Found config:", config ? "YES" : "NO");
                console.log(">>> feature.attributes:", feature.attributes);

                if (config && feature.attributes) {
                    console.log(">>> Entering config processing...");
                    try {
                        const displayInfo = config.displayFields(feature.attributes);

                        // æª¢æŸ¥ buildTargetName æ˜¯å¦å­˜åœ¨
                        let targetName;
                        if (config.buildTargetName && typeof config.buildTargetName === 'function') {
                            targetName = config.buildTargetName(feature.attributes);
                        } else {
                            // å¦‚æœæ²’æœ‰ buildTargetNameï¼Œç”¨ title ä½œç‚ºåç¨±
                            targetName = displayInfo.title;
                            console.warn(">>> buildTargetName not found, using displayInfo.title");
                        }

                        console.log("=== Starting navigation target save process ===");
                        console.log("Target name:", targetName);
                        console.log("Feature geometry:", feature.geometry);

                        snackbarText.value = `å·²å®šä½è‡³: ${displayInfo.title} (${displayInfo.subtitle})`;

                        // ç¢ºä¿ window.navigationTargetsData å­˜åœ¨
                        if (!window.navigationTargetsData) {
                            window.navigationTargetsData = [];
                            console.log("Initialized window.navigationTargetsData");
                        }

                        // è½‰æ›åº§æ¨™ç‚º WGS84 ä»¥å„²å­˜å°èˆªç›®æ¨™
                        try {
                            let wgs84Point;
                            const geomSR = feature.geometry.spatialReference;
                            console.log("Feature geometry SR:", geomSR);

                            if (geomSR.wkid === 4326 || geomSR.latestWkid === 4326) {
                                wgs84Point = feature.geometry;
                                console.log("Already WGS84, using directly");
                            } else {
                                // ç¢ºèªæŠ•å½±æ¨¡çµ„å·²è¼‰å…¥
                                if (!projectionModule) {
                                    console.error("projectionModule is null!");
                                } else if (!projectionModule.isLoaded()) {
                                    console.log("Projection not loaded, loading now...");
                                    await projectionModule.load();
                                }

                                console.log("Converting from", geomSR.wkid, "to WGS84");
                                wgs84Point = await projectionModule.project(
                                    feature.geometry,
                                    { wkid: 4326 }
                                );
                                console.log("Converted wgs84Point:", wgs84Point);
                            }

                            if (wgs84Point && (wgs84Point.longitude !== undefined || wgs84Point.x !== undefined)) {
                                // å„²å­˜å°èˆªç›®æ¨™
                                const navTarget = {
                                    name: targetName,
                                    longitude: wgs84Point.longitude || wgs84Point.x,
                                    latitude: wgs84Point.latitude || wgs84Point.y,
                                    timestamp: Date.now()
                                };

                                console.log("Creating nav target:", navTarget);

                                // é¿å…é‡è¤‡ï¼Œæª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸åŒåç¨±
                                const existingIndex = window.navigationTargetsData.findIndex(t => t.name === targetName);
                                if (existingIndex >= 0) {
                                    window.navigationTargetsData.splice(existingIndex, 1);
                                    console.log("Removed existing target");
                                }

                                // æ–°å¢åˆ°åˆ—è¡¨å‰é¢ï¼Œæœ€å¤šä¿ç•™ 20 å€‹
                                window.navigationTargetsData.unshift(navTarget);
                                if (window.navigationTargetsData.length > 20) {
                                    window.navigationTargetsData = window.navigationTargetsData.slice(0, 20);
                                }

                                console.log("âœ“ Navigation target saved to window:", navTarget);
                                console.log("âœ“ Total navigation targets:", window.navigationTargetsData.length);
                                console.log("âœ“ All targets in window:", JSON.stringify(window.navigationTargetsData));

                                // é¡¯ç¤º PopupTemplate
                                view.popup.open({
                                    title: targetName,
                                    content: `<b>${displayInfo.subtitle}</b><br>ç¶“åº¦: ${navTarget.longitude.toFixed(6)}<br>ç·¯åº¦: ${navTarget.latitude.toFixed(6)}`,
                                    location: feature.geometry
                                });
                            } else {
                                console.error("âœ— Failed to convert coordinates to WGS84, wgs84Point:", wgs84Point);
                            }
                        } catch (convErr) {
                            console.error("âœ— Coordinate conversion error:", convErr);
                        }

                    } catch (err) {
                        console.error("âœ— Display fields error:", err);
                        snackbarText.value = `å·²å®šä½è‡³æŸ¥è©¢çµæœ`;
                    }
                } else {
                    console.warn(">>> Config or attributes missing!");
                    console.warn(">>> config:", config);
                    console.warn(">>> feature.attributes:", feature.attributes);
                    snackbarText.value = `å·²å®šä½è‡³æŸ¥è©¢çµæœ`;
                }

                showSnackbar.value = true;
                if (snackbarTimer) clearTimeout(snackbarTimer);
                snackbarTimer = setTimeout(() => {
                    showSnackbar.value = false;
                }, 3000);
            } catch (error) {
                console.error("âœ— Zoom to result error:", error);
                console.error("âœ— Error stack:", error.stack);
                snackbarText.value = "å®šä½æ™‚ç™¼ç”ŸéŒ¯èª¤";
                showSnackbar.value = true;
                if (snackbarTimer) clearTimeout(snackbarTimer);
                snackbarTimer = setTimeout(() => {
                    showSnackbar.value = false;
                }, 3000);
            }
        };

        // è§¸ç™¼å®šä½åŠŸèƒ½ (åˆ‡æ›æ¨¡å¼)
        const triggerLocate = () => {
            if (!locateWidget || !view) return;

            // å¦‚æœå·²ç¶“å®šä½ï¼Œå‰‡å–æ¶ˆå®šä½
            if (isLocationActive.value) {
                // ç§»é™¤å®šä½æ¨™è¨˜
                if (locationGraphic) {
                    view.graphics.remove(locationGraphic);
                    locationGraphic = null;
                }
                isLocationActive.value = false;
                isLocating.value = false;
                console.log("Location tracking stopped");
                return;
            }

            // é–‹å§‹å®šä½
            isLocating.value = true;

            // ä½¿ç”¨ locate widget å®šä½
            locateWidget.locate().then(() => {
                console.log("Location found");
                isLocating.value = false;
                isLocationActive.value = true;

                // å®šä½æˆåŠŸå¾Œè¨­ç½®æ¯”ä¾‹ç‚º 500
                setTimeout(() => {
                    view.scale = 500;
                }, 500);
            }).catch((error) => {
                console.error("Location error:", error);
                isLocating.value = false;
                isLocationActive.value = false;

                snackbarText.value = "ç„¡æ³•å–å¾—ä½ç½®ï¼Œè«‹ç¢ºèªå·²é–‹å•Ÿå®šä½æ¬Šé™";
                showSnackbar.value = true;
                if (snackbarTimer) clearTimeout(snackbarTimer);
                snackbarTimer = setTimeout(() => {
                    showSnackbar.value = false;
                }, 3000);
            });
        };

        // ===== å·¡å‹˜åŠŸèƒ½ =====

        // é–‹å§‹å·¡å‹˜
        const startInspection = () => {
            console.log("Starting inspection from menu");

            if (window.InspectionModule) {
                InspectionModule.startInspection();
            } else {
                console.error("InspectionModule not loaded");
                snackbarText.value = "å·¡å‹˜æ¨¡çµ„æœªè¼‰å…¥";
                showSnackbar.value = true;
                if (snackbarTimer) clearTimeout(snackbarTimer);
                snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 2000);
            }
        };

        // é¡¯ç¤ºäº¤æ›å±€é¸æ“‡å°è©±æ¡†
        const showExgnoDialog = (exgnoList) => {
            console.log("Showing exgno dialog with items:", exgnoList);

            inspectionListType = 'exgno';
            inspectionListTitle.value = 'é¸æ“‡äº¤æ›å±€';
            inspectionListItems.value = exgnoList.map(exgno => ({
                value: exgno,
                text: exgno
            }));
            inspectionListVisible.value = true;
        };

        // é¡¯ç¤ºé“è·¯é¸æ“‡å°è©±æ¡†
        const showRoadDialog = (roadList) => {
            console.log("Showing road dialog with items:", roadList);

            inspectionListType = 'road';
            inspectionListTitle.value = 'é¸æ“‡é“è·¯';
            inspectionListItems.value = roadList.map(road => ({
                value: road.road,
                text: `${road.road} (${road.statusText})`
            }));
            inspectionListVisible.value = true;
        };

        // é¡¯ç¤ºè¨­å‚™é¸æ“‡å°è©±æ¡†
        const showDeviceDialog = (deviceList) => {
            console.log("Showing device dialog with items:", deviceList);

            inspectionListType = 'device';
            inspectionListTitle.value = 'é¸æ“‡è¨­å‚™';
            inspectionListItems.value = deviceList.map(device => ({
                value: device,
                text: device.displayText
            }));
            inspectionListVisible.value = true;
        };

        // é¸æ“‡åˆ—è¡¨é …ç›®
        const selectInspectionItem = (item) => {
            console.log("Selected inspection item:", item, "type:", inspectionListType);

            closeInspectionList();

            if (inspectionListType === 'exgno') {
                InspectionModule.selectExgno(item.value);
            } else if (inspectionListType === 'road') {
                InspectionModule.selectRoad(item.value);
            } else if (inspectionListType === 'device') {
                InspectionModule.selectDevice(item.value);
            }
        };

        // é—œé–‰å·¡å‹˜åˆ—è¡¨å°è©±æ¡†
        const closeInspectionList = () => {
            inspectionListVisible.value = false;
        };

        // é¡¯ç¤ºè¨Šæ¯ï¼ˆçµ¦å·¡å‹˜æ¨¡çµ„ç”¨ï¼‰
        const showInspectionMessage = (message) => {
            snackbarText.value = message;
            showSnackbar.value = true;
            if (snackbarTimer) clearTimeout(snackbarTimer);
            snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 3000);
        };

        // åŸ·è¡Œè¨­å‚™æŸ¥è©¢ï¼ˆçµ¦å·¡å‹˜æ¨¡çµ„ç”¨ï¼‰
        const executeDeviceQuery = async (queryParams) => {
            console.log('Executing device query:', queryParams);

            try {
                // å¾ layerList æ‰¾åœ–å±¤
                const targetLayer = layerList.find(l => l.name === queryParams.layerGroup);
                if (!targetLayer || !targetLayer.url) {
                    throw new Error(`æ‰¾ä¸åˆ°${queryParams.layerGroup}åœ–å±¤`);
                }

                // è¼‰å…¥åœ–å±¤ä»¥å–å¾— sublayers
                const tempLayer = new MapImageLayerClass({
                    url: targetLayer.url,
                    customParameters: { token: appToken }
                });

                await tempLayer.load();

                // ä½¿ç”¨ findLayerUrl æ‰¾åˆ°ç›®æ¨™åœ–å±¤
                const targetLayerUrl = findLayerUrl(tempLayer, queryParams.layerName);

                if (!targetLayerUrl) {
                    throw new Error(`æ‰¾ä¸åˆ°${queryParams.layerName}åœ–å±¤`);
                }

                console.log(`Device Query Layer URL:`, targetLayerUrl);

                // å»ºç«‹ FeatureLayer ä¾†åŸ·è¡ŒæŸ¥è©¢
                const queryLayer = new FeatureLayerClass({
                    url: targetLayerUrl,
                    customParameters: { token: appToken }
                });

                // å»ºç«‹æŸ¥è©¢åƒæ•¸
                const query = queryLayer.createQuery();
                query.where = queryParams.whereClause;
                query.outFields = ["*"];
                query.returnGeometry = true;

                console.log("Device Query WHERE clause:", query.where);

                // åŸ·è¡ŒæŸ¥è©¢
                const results = await queryLayer.queryFeatures(query);

                console.log("Device Query results:", results.features.length, "features found");

                if (results.features.length === 0) {
                    snackbarText.value = `æŸ¥ç„¡ ${queryParams.displayName} ${queryParams.deviceName}`;
                    showSnackbar.value = true;
                    if (snackbarTimer) clearTimeout(snackbarTimer);
                    snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 3000);
                    return;
                }

                // ä½¿ç”¨ markRaw é¿å… Vue å˜—è©¦å°‡è¤‡é›œçš„ Graphic ç‰©ä»¶è½‰æ›ç‚ºéŸ¿æ‡‰å¼
                queryResults.value = results.features.map(feature => markRaw(feature));

                // è¨­å®šç•¶å‰æŸ¥è©¢é¡å‹ï¼ˆç”¨æ–¼é¡¯ç¤ºï¼‰
                currentQueryType.value = `${queryParams.displayName}æŸ¥è©¢`;

                console.log("Setting device query results with markRaw, count:", queryResults.value.length);

                if (results.features.length === 1) {
                    // åªæœ‰ä¸€ç­†ï¼Œç›´æ¥ç¸®æ”¾
                    console.log("Single device result, zooming directly");
                    zoomToResult(results.features[0]);

                    snackbarText.value = `å·²å®šä½åˆ° ${queryParams.displayName}: ${queryParams.deviceName}`;
                    showSnackbar.value = true;
                    if (snackbarTimer) clearTimeout(snackbarTimer);
                    snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 3000);
                } else {
                    // å¤šç­†ï¼Œé¡¯ç¤ºåˆ—è¡¨è®“ç”¨æˆ¶é¸æ“‡
                    console.log("Multiple device results, showing list");
                    isResultListVisible.value = true;

                    snackbarText.value = `æ‰¾åˆ° ${results.features.length} ç­† ${queryParams.displayName}`;
                    showSnackbar.value = true;
                    if (snackbarTimer) clearTimeout(snackbarTimer);
                    snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 2000);
                }

            } catch (error) {
                console.error("Device query error:", error);
                snackbarText.value = "è¨­å‚™æŸ¥è©¢ç™¼ç”ŸéŒ¯èª¤: " + error.message;
                showSnackbar.value = true;
                if (snackbarTimer) clearTimeout(snackbarTimer);
                snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 3000);
            }
        };

        // === è»Œè·¡å·¡å‹˜å‡½æ•¸ ===

        // é–‹å§‹è»Œè·¡å·¡å‹˜
        const startTrackInspection = () => {
            console.log('é–‹å§‹è»Œè·¡å·¡å‹˜');

            // ç›´æ¥è¨­å®šç‹€æ…‹ï¼ˆä¸ä¾è³´æ¨¡çµ„å›èª¿ï¼‰
            isTracking.value = true;
            trackStatus.value = 'æ­£åœ¨å®šä½...';

            if (window.TrackInspectionModule) {
                TrackInspectionModule.startTracking();
            } else {
                console.error('TrackInspectionModule æœªå°±ç·’');
                showInspectionMessage('è»Œè·¡å·¡å‹˜æ¨¡çµ„æœªå°±ç·’');
                isTracking.value = false;
            }
        };

        // åœæ­¢è»Œè·¡å·¡å‹˜
        const stopTrackInspection = async () => {
            console.log('åœæ­¢è»Œè·¡å·¡å‹˜');

            // ç›´æ¥è¨­å®šç‹€æ…‹
            isTracking.value = false;
            trackStatus.value = '';

            if (window.TrackInspectionModule) {
                await TrackInspectionModule.stopTracking(
                    layerList,
                    findLayerUrl,
                    FeatureLayerClass,
                    MapImageLayerClass,
                    appToken
                );
            }
        };

        // æš´éœ²è‡ªå‹•åœæ­¢å‡½æ•¸çµ¦æ¸¬è©¦åº§æ¨™æ¨¡å¼ä½¿ç”¨
        window.autoStopTrackInspection = stopTrackInspection;

        // === è·¨è¶Šçºœç·šå…¨åŸŸå›èª¿ ===

        // ç…§ç‰‡é¸æ“‡å®Œæˆï¼ˆä¾› Android å‘¼å«ï¼‰
        window.onCablePhotoSelected = (base64) => {
            onPhotoSelected(base64);
        };

        // é›»æ¡¿è³‡è¨Šæ¥æ”¶å®Œæˆï¼ˆä¾› Android å‘¼å«ï¼‰
        window.onPolesInfoReceived = (jsonString) => {
            if (window.CableCrossingModule) {
                const data = CableCrossingModule.handlePolesInfoResponse(jsonString);
                if (data) {
                    onPolesInfoReceived(data);
                }
            }
        };

        // é€å‡ºçµæœï¼ˆä¾› Android å‘¼å«ï¼‰
        window.onCableSubmitResult = (success, message) => {
            if (window.CableCrossingModule) {
                CableCrossingModule.handleSubmitResult(success, message);
            }

            if (success) {
                onCableSubmitSuccess();
            }
        };

        // åˆ‡æ›äººå“¡å®Œæˆï¼ˆä¾› Android å‘¼å«ï¼‰
        window.onUserSwitched = (empNo) => {
            console.log('åˆ‡æ›äººå“¡å®Œæˆ:', empNo);
            ldap.value = empNo;
        };

        // é¡¯ç¤ºè¡Œæ”¿å€æ¸…å–®ï¼ˆVue ç‰ˆæœ¬ï¼‰
        window.showConstructionDistrictList = (districts, city) => {
            districtList.value = districts;
            currentCity.value = city;
            isDistrictListVisible.value = true;
            console.log('é¡¯ç¤ºè¡Œæ”¿å€æ¸…å–®:', districts);
        };

        // é¸æ“‡è¡Œæ”¿å€
        const selectConstructionDistrict = (district) => {
            console.log('é¸æ“‡è¡Œæ”¿å€:', district);
            isDistrictListVisible.value = false;

            if (currentCity.value === 'taipei' && window.TaipeiConstructionModule) {
                TaipeiConstructionModule.selectDistrict(district);
            } else if (currentCity.value === 'newtaipei' && window.NewTaipeiConstructionModule) {
                NewTaipeiConstructionModule.selectDistrict(district);
            } else if (currentCity.value === 'taoyuan' && window.TaoyuanConstructionModule) {
                TaoyuanConstructionModule.selectDistrict(district);
            }
        };

        // æ–½å·¥è³‡æ–™æ¥æ”¶ï¼ˆä¾› Android å‘¼å«ï¼‰
        window.onConstructionDataReceived = (data, city) => {
            console.log('æ”¶åˆ°æ–½å·¥è³‡æ–™:', city, typeof data);
            try {
                // data å·²ç¶“æ˜¯ JSON ç‰©ä»¶ï¼Œä¸éœ€è¦ parse
                if (city === 'taipei' && window.TaipeiConstructionModule) {
                    TaipeiConstructionModule.processConstructionData(data);
                } else if (city === 'newtaipei' && window.NewTaipeiConstructionModule) {
                    NewTaipeiConstructionModule.processConstructionData(data);
                }
            } catch (e) {
                console.error('è™•ç†æ–½å·¥è³‡æ–™å¤±æ•—:', e);
            }
        };

        // é¡¯ç¤ºè»Œè·¡ç¢ºèªå°è©±æ¡†
        const showTrackConfirmDialog = (data) => {
            console.log('é¡¯ç¤ºè»Œè·¡ç¢ºèªå°è©±æ¡†:', data);

            trackDeviceCounts.value = data.deviceCounts || {};

            // çµ„åˆè¨­å‚™æ¸…å–®æ–‡å­—
            const allDevices = [
                ...(data.poleDevices || []),
                ...(data.otherDevices || [])
            ];
            trackDeviceList.value = allDevices.join(', ');

            trackScreenshot.value = data.screenshot || '';

            // æª¢æŸ¥æˆªåœ–
            if (data.screenshot) {
                console.log('æˆªåœ–è³‡æ–™é•·åº¦:', data.screenshot.length);
                console.log('æˆªåœ–æ ¼å¼:', data.screenshot.substring(0, 30));
            } else {
                console.warn('è­¦å‘Šï¼šæˆªåœ–è³‡æ–™ç‚ºç©º');
            }

            trackConfirmVisible.value = true;
        };

        // ç¢ºèªé€å‡ºè»Œè·¡
        const confirmTrackSend = () => {
            console.log('ç¢ºèªé€å‡ºè»Œè·¡');

            trackConfirmVisible.value = false;

            if (window.TrackInspectionModule) {
                TrackInspectionModule.confirmAndSend();
            }

            showInspectionMessage('è»Œè·¡å·²é€å‡ºï¼ˆAPI å¾…å¯¦ä½œï¼‰');
        };
        window.onConstructionDataReceived = function(data, city) {
    console.log('æ”¶åˆ°æ–½å·¥è³‡æ–™:', city, data);

    if (city === 'taipei' && window.TaipeiConstructionModule) {
        TaipeiConstructionModule.processConstructionData(data);
    } else if (city === 'newtaipei' && window.NewTaipeiConstructionModule) {
        NewTaipeiConstructionModule.processConstructionData(data);
    }
    // æ¡ƒåœ’ä¸ä½¿ç”¨æ­¤æ–¹æ³•
};

        // å–æ¶ˆè»Œè·¡
        const cancelTrackConfirm = () => {
            console.log('å–æ¶ˆè»Œè·¡');

            trackConfirmVisible.value = false;

            if (window.TrackInspectionModule) {
                TrackInspectionModule.cancelTrack();
            }
        };

        // ä¸Šæ¬¡è»Œè·¡é‡é€
        const resendLastTrack = async () => {
            console.log('ä¸Šæ¬¡è»Œè·¡é‡é€');

            if (!window.TrackInspectionModule) {
                console.error('TrackInspectionModule æœªå°±ç·’');
                showInspectionMessage('è»Œè·¡å·¡å‹˜æ¨¡çµ„æœªå°±ç·’');
                return;
            }

            // æª¢æŸ¥æ˜¯å¦æ­£åœ¨è¿½è¹¤
            if (isTracking.value) {
                showInspectionMessage('è«‹å…ˆåœæ­¢ç›®å‰çš„è»Œè·¡è¨˜éŒ„');
                return;
            }

            // å‘¼å«æ¨¡çµ„çš„é‡é€åŠŸèƒ½
            try {
                await TrackInspectionModule.resendLastTrack();
            } catch (error) {
                console.error('é‡é€è»Œè·¡å¤±æ•—:', error);
                showInspectionMessage('é‡é€è»Œè·¡å¤±æ•—: ' + error.message);
            }
        };

        // æ›´æ–°è»Œè·¡ç‹€æ…‹
        const updateTrackStatus = (data) => {
            if (data.warmup) {
                trackStatus.value = 'é ç†±ä¸­...';
            } else {
                trackStatus.value = `å·²è¨˜éŒ„ ${data.pointCount} å€‹é»`;
            }
        };

        // è»Œè·¡é–‹å§‹å›èª¿
        const onTrackingStarted = () => {
            console.log('è»Œè·¡è¨˜éŒ„å·²é–‹å§‹');
            isTracking.value = true;
            trackStatus.value = 'æ­£åœ¨å®šä½...';
        };

        // è»Œè·¡åœæ­¢å›èª¿
        const onTrackingStopped = () => {
            console.log('è»Œè·¡è¨˜éŒ„å·²åœæ­¢');
            isTracking.value = false;
            trackStatus.value = '';
        };

        // é‡é€è»Œè·¡
        const resendTrack = () => {
            console.log('é‡é€è»Œè·¡');

            if (window.TrackInspectionModule) {
                const trackData = TrackInspectionModule.loadSavedTrack();

                if (trackData) {
                    // é¡¯ç¤ºç¢ºèªå°è©±æ¡†
                    showTrackConfirmDialog(trackData);
                }
            } else {
                console.error('TrackInspectionModule æœªå°±ç·’');
                showInspectionMessage('è»Œè·¡å·¡å‹˜æ¨¡çµ„æœªå°±ç·’');
            }
        };

        // ç›£è½æ–‡å­—è¼¸å…¥å°è©±æ¡†é¡¯ç¤ºï¼Œè‡ªå‹•èšç„¦
        watch(isTextInputDialogVisible, (newVal) => {
            if (newVal) {
                nextTick(() => {
                    const input = document.querySelector('.text-input-dialog-input');
                    if (input) {
                        input.focus();
                    }
                });
            }
        });

        // ç›£è½å·¥ä½œæ–‡å­—å°è©±æ¡†é¡¯ç¤ºï¼Œè‡ªå‹•èšç„¦
        watch(isWorkTextDialogVisible, (newVal) => {
            if (newVal) {
                nextTick(() => {
                    const inputs = document.querySelectorAll('.text-input-dialog-input');
                    const workTextInput = inputs[inputs.length - 1]; // å–æœ€å¾Œä¸€å€‹ï¼ˆå·¥ä½œæ–‡å­—è¼¸å…¥æ¡†ï¼‰
                    if (workTextInput) {
                        workTextInput.focus();
                    }
                });
            }
        });

        // åˆå§‹åŒ–åœ°åœ–
        onMounted(() => {
            require([
              "esri/Map",
              "esri/views/MapView",
              "esri/layers/MapImageLayer",
              "esri/layers/WMTSLayer",
              "esri/identity/IdentityManager",
              "esri/core/reactiveUtils",
              "esri/geometry/projection",
              "esri/geometry/SpatialReference",
              "esri/geometry/Point",
              "esri/Graphic",
              "esri/symbols/SimpleMarkerSymbol",
              "esri/symbols/TextSymbol",
              "esri/widgets/Locate",
              "esri/layers/FeatureLayer",
              "esri/geometry/Polyline",
              "esri/geometry/Polygon",
              "esri/symbols/SimpleLineSymbol",
              "esri/geometry/geometryEngine",
              "esri/layers/GraphicsLayer"
            ], function(Map, MapView, MapImageLayer, WMTSLayer, esriId, rUtils, projection, SpatialReference, Point, Graphic, SimpleMarkerSymbol, TextSymbol, Locate, FeatureLayer, Polyline, Polygon, SimpleLineSymbol, geoEngine, GraphicsLayerClass) {
                MapImageLayerClass = MapImageLayer;
                WMTSLayerClass = WMTSLayer;
                reactiveUtils = rUtils;
                IdentityManager = esriId;
                LocateWidget = Locate;
                GraphicClass = Graphic;
                SimpleMarkerSymbolClass = SimpleMarkerSymbol;
                TextSymbolClass = TextSymbol;
                FeatureLayerClass = FeatureLayer;
                PointClass = Point;
                projectionModule = projection;
                SpatialReferenceClass = SpatialReference;
                PolylineClass = Polyline;
                PolygonClass = Polygon;
                SimpleLineSymbolClass = SimpleLineSymbol;
                geometryEngine = geoEngine;
                GraphicsLayer = GraphicsLayerClass;

                if (appToken) {
                    IdentityManager.registerToken({
                        server: "https://gisapp.cht.com.tw/arcgis107/rest/services",
                        token: appToken
                    });
                }

                // è¼‰å…¥æŠ•å½±æ¨¡çµ„
                projection.load().then(() => {
                    console.log("Projection module loaded");
                }).catch(err => {
                    console.error("Failed to load projection module:", err);
                });

                // å»ºç«‹åœ°åœ– (ä¸è¨­å®š basemapï¼Œç”±å¾ŒçºŒå‡½æ•¸è™•ç†)
                map = new Map();

                view = new MapView({
                    container: "viewDiv",
                    map: map,
                    center: [121.5, 25.0],
                    zoom: 8
                });

                // å°‡ view è¨­ç‚ºå…¨å±€è®Šæ•¸ä»¥ä¾› Android æˆªåœ–åŠŸèƒ½è¨ªå•
                window.mapView = view;
                console.log("MapView set to window.mapView");

                // å»ºç«‹ Locate widget (ä¸åŠ åˆ° UIï¼Œç”¨è‡ªè¨‚æŒ‰éˆ•æ§åˆ¶)
                locateWidget = new Locate({
                    view: view,
                    useHeadingEnabled: false,
                    goToOverride: function(view, options) {
                        // è‡ªè¨‚å®šä½å¾Œçš„è¡Œç‚º
                        options.target.scale = 500;
                        return view.goTo(options.target);
                    },
                    graphic: new Graphic({
                        symbol: new SimpleMarkerSymbol({
                            color: [0, 120, 255, 0.8],
                            outline: {
                                color: [255, 255, 255],
                                width: 3
                            },
                            size: 14
                        })
                    })
                });

                // ç›£è½å®šä½æˆåŠŸäº‹ä»¶ï¼Œå„²å­˜å®šä½æ¨™è¨˜
                locateWidget.on("locate", (event) => {
                    locationGraphic = event.graphic;
                });

                view.watch("scale", (newScale) => {
                    const scaleText = document.getElementById("scaleText");
                    if (scaleText) {
                        const rounded = Math.round(newScale).toLocaleString();
                        scaleText.textContent = `ç¸®å°º 1:${rounded}`;
                    }
                });

                view.ui.remove("zoom");

                initLayerList();

                // è¨­å®šé è¨­åº•åœ–ç‚º CHTGIS
                setupChtBasemap();

                // åœ°åœ–è¼‰å…¥å®Œæˆå¾Œæ‰ç¶å®šäº‹ä»¶
                view.when(() => {
                    console.log("MapView is ready");

                    // åœ°åœ–é»æ“Šäº‹ä»¶é¡¯ç¤ºåº§æ¨™
                    coordinateClickHandler = view.on("click", async (evt) => {
                        // å¦‚æœæ­£åœ¨ç¹ªåœ–æˆ–æ¨™è¨»ï¼Œä¸è™•ç†åº§æ¨™é¡¯ç¤º
                        if (isDrawToolbarVisible.value || isAnnotationToolbarVisible.value) {
                            console.log("Drawing/Annotation mode active, skipping coordinate display");
                            return;
                        }

                        // æª¢æŸ¥æ˜¯å¦é»åˆ°æ–½å·¥é»åœ–å±¤
                        try {
                            const hitResponse = await view.hitTest(evt);
                            if (hitResponse.results.length > 0) {
                                for (let result of hitResponse.results) {
                                    if (result.graphic && result.graphic.layer && result.graphic.layer.title) {
                                        const layerTitle = result.graphic.layer.title;
                                        // å¦‚æœé»åˆ°æ–½å·¥é»åœ–å±¤ï¼Œä¸é¡¯ç¤ºåº§æ¨™
                                        if (layerTitle === 'å°åŒ—å¸‚æ–½å·¥ä½ç½®' ||
                                            layerTitle === 'æ–°åŒ—å¸‚æ–½å·¥ä½ç½®' ||
                                            layerTitle === 'æ¡ƒåœ’å¸‚æ–½å·¥ä½ç½®') {
                                            console.log("é»åˆ°æ–½å·¥é»åœ–å±¤ï¼Œä¸é¡¯ç¤ºåº§æ¨™");
                                            return;
                                        }
                                    }
                                }
                            }
                        } catch (hitErr) {
                            console.error("hitTest å¤±æ•—:", hitErr);
                        }

                        try {
                            console.log("Map clicked!");
                            console.log("evt.mapPoint:", evt.mapPoint);
                            console.log("evt.mapPoint.spatialReference:", evt.mapPoint.spatialReference);

                            // mapPoint å¯èƒ½ç”¨ x/y è€Œä¸æ˜¯ longitude/latitude
                            let lon, lat;

                            // æª¢æŸ¥ mapPoint çš„åº§æ¨™ç³»çµ±
                            if (evt.mapPoint.spatialReference.wkid === 4326 || evt.mapPoint.spatialReference.latestWkid === 4326) {
                                // WGS84 - ä½¿ç”¨ longitude/latitude æˆ– x/y
                                lon = evt.mapPoint.longitude || evt.mapPoint.x;
                                lat = evt.mapPoint.latitude || evt.mapPoint.y;
                            } else {
                                // å…¶ä»–åº§æ¨™ç³»çµ± - éœ€è¦è½‰æ›
                                try {
                                    if (!projectionModule.isLoaded()) {
                                        await projectionModule.load();
                                    }
                                    const wgsPoint = await projectionModule.project(evt.mapPoint, { wkid: 4326 });
                                    if (wgsPoint) {
                                        lon = wgsPoint.longitude || wgsPoint.x;
                                        lat = wgsPoint.latitude || wgsPoint.y;
                                    }
                                } catch (projErr) {
                                    console.error("Failed to convert to WGS84:", projErr);
                                }
                            }

                            console.log("Extracted lon/lat:", lon, lat);

                            if (lon && lat) {
                                const lonF = lon.toFixed(6);
                                const latF = lat.toFixed(6);

                                // å˜—è©¦è½‰æ› TWD97
                                try {
                                    const wgsPoint = new PointClass({
                                        x: lon,
                                        y: lat,
                                        spatialReference: { wkid: 4326 }
                                    });

                                    if (!projectionModule.isLoaded()) {
                                        await projectionModule.load();
                                    }

                                    const twd97 = await projectionModule.project(wgsPoint, { wkid: 3826 });

                                    if (twd97 && (twd97.x || twd97.x === 0) && (twd97.y || twd97.y === 0)) {
                                        const x97 = Number(twd97.x).toFixed(2);
                                        const y97 = Number(twd97.y).toFixed(2);
                                        snackbarText.value = `TWD97: ${x97}, ${y97}  ï½œ  Lon: ${lonF}, Lat: ${latF}`;
                                    } else {
                                        snackbarText.value = `Lon: ${lonF}, Lat: ${latF}`;
                                    }
                                } catch (projErr) {
                                    console.error("Projection error:", projErr);
                                    snackbarText.value = `Lon: ${lonF}, Lat: ${latF}`;
                                }

                                showSnackbar.value = true;
                                if (snackbarTimer) clearTimeout(snackbarTimer);
                                snackbarTimer = setTimeout(() => {
                                    showSnackbar.value = false;
                                }, 3000);
                            } else {
                                console.error("Could not extract coordinates from mapPoint");
                            }
                        } catch (err) {
                            console.error("Click handling error:", err);
                        }
                    });

                    // å»¶é² 1 ç§’å¾Œè‡ªå‹•å®šä½åˆ° GPS ä½ç½®
                    setTimeout(() => {
                        triggerLocate();
                    }, 1000);

                    // åˆå§‹åŒ–è»Œè·¡å·¡å‹˜æ¨¡çµ„ï¼ˆç­‰å¾… projection è¼‰å…¥ï¼‰
                    const initTrackModule = () => {
                        if (window.TrackInspectionModule && projectionModule) {
                            console.log('åˆå§‹åŒ– TrackInspectionModule...');

                            TrackInspectionModule.init(
                                {
                                    view: view,
                                    Graphic: GraphicClass,
                                    Polyline: PolylineClass,
                                    SimpleLineSymbol: SimpleLineSymbolClass,
                                    geometryEngine: geometryEngine,
                                    projection: projectionModule,
                                    reactiveUtils: reactiveUtils
                                },
                                {
                                    onUpdateStatus: updateTrackStatus,
                                    onShowConfirmDialog: showTrackConfirmDialog,
                                    onShowMessage: showInspectionMessage,
                                    onTrackingStarted: onTrackingStarted,
                                    onTrackingStopped: onTrackingStopped
                                }
                            );

                            console.log('âœ“ TrackInspectionModule åˆå§‹åŒ–å®Œæˆ');
                        } else {
                            // projection å¯èƒ½é‚„æ²’è¼‰å…¥ï¼Œç¨å¾Œé‡è©¦
                            setTimeout(initTrackModule, 100);
                        }
                    };

                    // åˆå§‹åŒ– CableCrossingModule
                    const initCableModule = () => {
                        if (window.CableCrossingModule) {
                            console.log('åˆå§‹åŒ– CableCrossingModule...');

                            CableCrossingModule.init(
                                {
                                    view: view,
                                    Graphic: GraphicClass,
                                    Point: PointClass,
                                    SimpleMarkerSymbol: SimpleMarkerSymbolClass,
                                    geometryEngine: geometryEngine,
                                    FeatureLayer: FeatureLayerClass,
                                    MapImageLayer: MapImageLayerClass
                                },
                                {
                                    onShowMessage: showInspectionMessage,
                                    onShowPoleList: showPoleList,
                                    onShowCableForm: () => { cableFormVisible.value = true; },
                                    onPolesInfoReceived: onPolesInfoReceived,
                                    onSubmitSuccess: onCableSubmitSuccess
                                }
                            );

                            console.log('âœ“ CableCrossingModule åˆå§‹åŒ–å®Œæˆ');
                        } else {
                            setTimeout(initCableModule, 100);
                        }
                    };

                    // å»¶é²åˆå§‹åŒ–ç¢ºä¿æ‰€æœ‰æ¨¡çµ„å°±ç·’
                    setTimeout(initTrackModule, 500);
                    setTimeout(initCableModule, 600);

                    // åˆå§‹åŒ–æ–½å·¥ä½ç½®æ¨¡çµ„
                    const initConstructionModules = () => {
                        if (window.TaipeiConstructionModule) {
                            TaipeiConstructionModule.init(
                                {
                                    onShowMessage: showInspectionMessage
                                },
                                {
                                    view: view,
                                    map: map,
                                    projection: projection,   // â­ ä¸€å®šè¦å‚³é€² init
                                    Graphic: GraphicClass,
                                    Polyline: PolylineClass,
                                    Polygon: PolygonClass,
                                    TextSymbol: TextSymbolClass,
                                    geometryEngine: geometryEngine,
                                    FeatureLayer: FeatureLayerClass,
                                    GraphicsLayer: GraphicsLayer,
                                    layerList: layerList,
                                    pipeLayerUrl: null  // å»¶é²åˆ°ä½¿ç”¨æ™‚æŸ¥æ‰¾
                                }
                            );
                        }

                        if (window.NewTaipeiConstructionModule) {
                            NewTaipeiConstructionModule.init({onShowMessage: showInspectionMessage});
                        }

                        if (window.TaoyuanConstructionModule) {
    TaoyuanConstructionModule.init(
        {onShowMessage: showInspectionMessage},
        {
            view: view,
            map: map,
            Graphic: GraphicClass,
            Point: PointClass,
            Multipoint: MultipointClass,
            Polyline: PolylineClass,
            Polygon: PolygonClass,
            TextSymbol: TextSymbolClass,
            geometryEngine: geometryEngine,
            FeatureLayer: FeatureLayerClass,
            GraphicsLayer: GraphicsLayer,
            layerList: layerList,
            projection: projection
        }
    );
    console.log('Point:', typeof window.Point);
console.log('Multipoint:', typeof window.Multipoint);
console.log('Polyline:', typeof window.Polyline);
console.log('Polygon:', typeof window.Polygon);
}
                    };

                    setTimeout(initConstructionModules, 700);
                });
            });
        });

        // åˆå§‹åŒ–å·¡å‹˜æ¨¡çµ„
        onMounted(() => {
            if (window.InspectionModule) {
                // å¾ Android å–å¾— ldap
                if (window.Android && window.Android.getLdap) {
                    ldap.value = window.Android.getLdap();
                    console.log("Got ldap from Android:", ldap.value);
                }

                // åˆå§‹åŒ–æ¨¡çµ„ä¸¦è¨­å®šå›èª¿
                InspectionModule.init(ldap.value, {
                    onShowExgnoDialog: showExgnoDialog,
                    onShowRoadDialog: showRoadDialog,
                    onShowDeviceDialog: showDeviceDialog,
                    onShowMessage: showInspectionMessage,
                    onExecuteDeviceQuery: executeDeviceQuery
                });

                console.log("InspectionModule initialized");
            } else {
                console.error("InspectionModule not available");
            }
        });

        // è¨­å®šèˆ‡åˆ‡æ› CHT åº•åœ–
        const setupChtBasemap = () => {
            if (!map || !MapImageLayerClass) return;

            if (baseLayer) map.remove(baseLayer);
            if (baseDyLayer) map.remove(baseDyLayer);
            if (nlscWmtsLayer) map.remove(nlscWmtsLayer);

            let sname = appArea;
            let snameUpper = appArea.toUpperCase();

            baseLayer = new MapImageLayerClass({
                url: `${baseUrl}${snameUpper}_CacheBase/MapServer`,
                visible: false,
                customParameters: { token: appToken }
            });

            baseDyLayer = new MapImageLayerClass({
                url: `${baseUrl}${snameUpper}_DyBase/MapServer`,
                visible: false,
                customParameters: { token: appToken }
            });

            map.add(baseLayer, 0);
            map.add(baseDyLayer, 0);

            if (chtBasemapScaleHandle) {
                chtBasemapScaleHandle.remove();
                chtBasemapScaleHandle = null;
            }

            updateChtBasemapVisibility(view.scale);

            chtBasemapScaleHandle = reactiveUtils.watch(
                () => view.scale,
                (scale) => {
                    updateChtBasemapVisibility(scale);
                }
            );

            console.log("CHTGIS basemap setup complete");
        };

        const updateChtBasemapVisibility = (scale) => {
            if (selectedBasemap.value !== 'CHTGIS') return;

            if (scale > 1500) {
                if(baseLayer) baseLayer.visible = true;
                if(baseDyLayer) baseDyLayer.visible = false;
            } else {
                if(baseLayer) baseLayer.visible = false;
                if(baseDyLayer) baseDyLayer.visible = true;
            }
        };

        // è¨­å®š NLSC WMTS åº•åœ–
        const setupNlscBasemap = () => {
            if (!map || !WMTSLayerClass) return;

            if (baseLayer) map.remove(baseLayer);
            if (baseDyLayer) map.remove(baseDyLayer);
            if (nlscWmtsLayer) map.remove(nlscWmtsLayer);

            if (chtBasemapScaleHandle) {
                chtBasemapScaleHandle.remove();
                chtBasemapScaleHandle = null;
            }

            nlscWmtsLayer = new WMTSLayerClass({
                url: "https://wmts.nlsc.gov.tw/97/wmts/EMAP3826/default/EPSG:3826",
                serviceMode: "KVP",
                activeLayer: {
                    id: "EMAP3826"
                }
            });

            map.add(nlscWmtsLayer, 0);

            console.log("NLSC WMTS basemap setup complete");
        };

        const changeBasemap = () => {
            if (!map) return;

            map.layers.removeAll();

            if (selectedBasemap.value === 'CHTGIS') {
                setupChtBasemap();
                console.log("Switched to CHTGIS");
            } else if (selectedBasemap.value === 'NLSC') {
                setupNlscBasemap();
                console.log("Switched to NLSC (åœ‹åœŸæ¸¬ç¹ª)");
            }

            setTimeout(() => {
                layerList.forEach(layer => {
                    if(layer.isEnabled) {
                        layer.layerObj = null;
                        toggleMapLayer(layer);
                    }
                });
            }, 500);
        };

        const toggleMainMenu = () => {
            isMainMenuVisible.value = !isMainMenuVisible.value;
            if (isMainMenuVisible.value) {
                currentSubMenu.value = null;
                isLayerDialogVisible.value = false;
            }
        };

        const openSubMenu = (menuName) => {
            isMainMenuVisible.value = false;
            currentSubMenu.value = menuName;
        };

        const openLayerDialog = () => {
            isMainMenuVisible.value = false;
            isLayerDialogVisible.value = true;
        };

        const closeAll = () => {
            isMainMenuVisible.value = false;
            currentSubMenu.value = null;
            isLayerDialogVisible.value = false;
            isQueryDialogVisible.value = false;
            isResultListVisible.value = false;
            isCoordinateDialogVisible.value = false;
            isNavigationDialogVisible.value = false;
        };

        // æ¸…é™¤æ‰€æœ‰åœ–å½¢
        const clearAllGraphics = () => {
            console.log('é–‹å§‹æ¸…é™¤æ‰€æœ‰åœ–å½¢...');

            let clearedCount = 0;

            // æ¸…é™¤ç¹ªåœ–åœ–å±¤
            if (sketchLayer) {
                const count = sketchLayer.graphics.length;
                sketchLayer.removeAll();
                clearedCount += count;
                console.log('å·²æ¸…é™¤ç¹ªåœ–åœ–å±¤:', count, 'å€‹åœ–å½¢');
            }

            // æ¸…é™¤æ¸¬é‡æ¨™ç±¤åœ–å±¤
            if (measurementLayer) {
                const count = measurementLayer.graphics.length;
                measurementLayer.removeAll();
                clearedCount += count;
                console.log('å·²æ¸…é™¤æ¸¬é‡æ¨™ç±¤åœ–å±¤:', count, 'å€‹åœ–å½¢');
            }

            // æ¸…é™¤æ¨™è¨»åœ–å±¤
            if (annotationLayer) {
                const count = annotationLayer.graphics.length;
                annotationLayer.removeAll();
                clearedCount += count;
                console.log('å·²æ¸…é™¤æ¨™è¨»åœ–å±¤:', count, 'å€‹åœ–å½¢');
            }

            // æ¸…é™¤å°åŒ—å¸‚æ–½å·¥ä½ç½®ç›¸é—œåœ–å±¤
            if (window.TaipeiConstructionModule) {
                // å¾åœ°åœ–ä¸­æ‰¾åˆ°æ–½å·¥ä½ç½®ç›¸é—œçš„ GraphicsLayer ä¸¦æ¸…é™¤
                if (map && map.layers) {
                    map.layers.forEach(layer => {
                        if (layer.title === "å°åŒ—å¸‚æ–½å·¥ä½ç½®" ||
                            layer.title === "æ–½å·¥ç¯„åœ" ||
                            layer.title === "æ–°åŒ—å¸‚æ–½å·¥ä½ç½®" ||
                            layer.title === "æ¡ƒåœ’å¸‚æ–½å·¥ä½ç½®") {
                            const count = layer.graphics ? layer.graphics.length : 0;
                            if (layer.removeAll) {
                                layer.removeAll();
                                clearedCount += count;
                                console.log('å·²æ¸…é™¤åœ–å±¤:', layer.title, count, 'å€‹åœ–å½¢');
                            }
                        }
                    });
                }
            }

            // æ¸…é™¤æŸ¥è©¢çµæœç›¸é—œçš„åœ–å½¢
            if (view && view.graphics) {
                const count = view.graphics.length;
                view.graphics.removeAll();
                clearedCount += count;
                console.log('å·²æ¸…é™¤view graphics:', count, 'å€‹åœ–å½¢');
            }

            // æ¸…é™¤popup
            if (view && view.popup) {
                view.popup.close();
            }

            console.log('æ¸…é™¤å®Œæˆï¼Œç¸½å…±æ¸…é™¤:', clearedCount, 'å€‹åœ–å½¢');

            // é¡¯ç¤ºè¨Šæ¯
            snackbarText.value = "å·²æ¸…é™¤ç•«é¢ (" + clearedCount + " å€‹åœ–å½¢)";
            showSnackbar.value = true;
            if (snackbarTimer) clearTimeout(snackbarTimer);
            snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 2000);
        };

        // å·¡å‹˜æ”¹å–„å›å ±åŠŸèƒ½
        const startImprovementReport = () => {
            console.log('é–‹å§‹å·¡å‹˜æ”¹å–„å›å ±');

            // é¡¯ç¤ºé¸æ“‡å°è©±æ¡†ï¼šæ¶ç©ºæˆ–åœ°ä¸‹è¨­å‚™
            const dialogHtml = `
                <div id="improvementTypeDialog" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 10000; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); min-width: 300px;">
                    <h3 style="margin-top: 0; color: #333;">é¸æ“‡è¨­å‚™é¡å‹</h3>
                    <button onclick="selectImprovementType('aerial')" style="width: 100%; padding: 12px; margin-bottom: 10px; border: none; border-radius: 4px; background: #2196F3; color: white; font-size: 16px; cursor: pointer;">æ¶ç©º</button>
                    <button onclick="selectImprovementType('underground')" style="width: 100%; padding: 12px; margin-bottom: 10px; border: none; border-radius: 4px; background: #4CAF50; color: white; font-size: 16px; cursor: pointer;">åœ°ä¸‹é¢è¨­å‚™</button>
                    <button onclick="closeImprovementTypeDialog()" style="width: 100%; padding: 12px; border: none; border-radius: 4px; background: #757575; color: white; font-size: 16px; cursor: pointer;">å–æ¶ˆ</button>
                </div>
                <div id="improvementTypeMask" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 9999;"></div>
            `;

            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = dialogHtml;
            document.body.appendChild(tempDiv);
        };

        // é¸æ“‡è¨­å‚™é¡å‹
        window.selectImprovementType = (type) => {
            console.log('é¸æ“‡è¨­å‚™é¡å‹:', type);

            // é—œé–‰é¸æ“‡å°è©±æ¡†
            const dialog = document.getElementById('improvementTypeDialog');
            const mask = document.getElementById('improvementTypeMask');
            if (dialog) dialog.parentElement.remove();
            if (mask) mask.remove();

            if (type === 'aerial') {
                // æ¶ç©º - ç›´æ¥æŸ¥è©¢é›»æ¡¿
                queryImprovementFacilities('é›»çºœåœ–', 'çºœé›»æ¡¿(G69)', 'FULLNO', 'aerial');
            } else if (type === 'underground') {
                // åœ°ä¸‹è¨­å‚™ - é¡¯ç¤ºå­é¸å–®
                showUndergroundFacilityMenu();
            }
        };

        // é¡¯ç¤ºåœ°ä¸‹è¨­å‚™å­é¸å–®
        const showUndergroundFacilityMenu = () => {
            const dialogHtml = `
                <div id="undergroundFacilityDialog" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 10000; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); min-width: 300px;">
                    <h3 style="margin-top: 0; color: #333;">é¸æ“‡åœ°ä¸‹è¨­å‚™</h3>
                    <button onclick="selectUndergroundFacility('manhole')" style="width: 100%; padding: 12px; margin-bottom: 10px; border: none; border-radius: 4px; background: #FF9800; color: white; font-size: 16px; cursor: pointer;">äººå­”</button>
                    <button onclick="selectUndergroundFacility('handhole')" style="width: 100%; padding: 12px; margin-bottom: 10px; border: none; border-radius: 4px; background: #FF5722; color: white; font-size: 16px; cursor: pointer;">æ‰‹å­”</button>
                    <button onclick="selectUndergroundFacility('terminal')" style="width: 100%; padding: 12px; margin-bottom: 10px; border: none; border-radius: 4px; background: #9C27B0; color: white; font-size: 16px; cursor: pointer;">äº¤æ¥ç®±</button>
                    <button onclick="closeUndergroundFacilityDialog()" style="width: 100%; padding: 12px; border: none; border-radius: 4px; background: #757575; color: white; font-size: 16px; cursor: pointer;">å–æ¶ˆ</button>
                </div>
                <div id="undergroundFacilityMask" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 9999;"></div>
            `;

            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = dialogHtml;
            document.body.appendChild(tempDiv);
        };

        // é¸æ“‡åœ°ä¸‹è¨­å‚™
        window.selectUndergroundFacility = (facilityType) => {
            console.log('é¸æ“‡åœ°ä¸‹è¨­å‚™:', facilityType);

            // é—œé–‰å°è©±æ¡†
            const dialog = document.getElementById('undergroundFacilityDialog');
            const mask = document.getElementById('undergroundFacilityMask');
            if (dialog) dialog.parentElement.remove();
            if (mask) mask.remove();

            let layerGroup = '';
            let layerName = '';
            let attributeName = '';

            if (facilityType === 'manhole') {
                layerGroup = 'ç®¡é“åœ–';
                layerName = 'ç®¡é“äººå­”(G60)';
                attributeName = 'FULLNO';
            } else if (facilityType === 'handhole') {
                layerGroup = 'ç®¡é“åœ–';
                layerName = 'ç®¡é“æ‰‹å­”(G61)';
                attributeName = 'FULLNO';
            } else if (facilityType === 'terminal') {
                layerGroup = 'å…‰çºœåœ–';
                layerName = 'æˆ¶å¤–çµ‚ç«¯';
                attributeName = 'CENTOFF,ACCNO'; // çµ„åˆå±¬æ€§
            }

            queryImprovementFacilities(layerGroup, layerName, attributeName, facilityType);
        };

        // æŸ¥è©¢æ”¹å–„è¨­æ–½
        const queryImprovementFacilities = (layerGroup, layerName, attributeName, facilityType) => {
            console.log('æŸ¥è©¢æ”¹å–„è¨­æ–½:', { layerGroup, layerName, attributeName, facilityType });

            // 1. æª¢æŸ¥æ¸¬è©¦åº§æ¨™ (gpspoint æ˜¯ TWD97 æ ¼å¼: x,y)
            let testCoords = null;
            if (window.Android && window.Android.getGpsPoint) {
                const gpsPoint = window.Android.getGpsPoint();
                console.log('æ¸¬è©¦åº§æ¨™ (gpspoint):', gpsPoint);

                if (gpsPoint && gpsPoint.trim() !== '') {
                    const coords = gpsPoint.split(',');
                    if (coords.length === 2) {
                        testCoords = {
                            x: parseFloat(coords[0]),
                            y: parseFloat(coords[1]),
                            isTWD97: true
                        };
                        console.log('ä½¿ç”¨æ¸¬è©¦åº§æ¨™ (TWD97):', testCoords);
                    }
                }
            }

            // 2. å¦‚æœæœ‰æ¸¬è©¦åº§æ¨™ï¼Œç›´æ¥ä½¿ç”¨ï¼ˆå·²ç¶“æ˜¯TWD97ï¼‰
            if (testCoords) {
                performFacilityQuery(testCoords.x, testCoords.y, true, layerGroup, layerName, attributeName, facilityType);
            } else {
                // 3. å¦‚æœæ²’æœ‰æ¸¬è©¦åº§æ¨™ï¼Œå–å¾—ç•¶å‰GPSä½ç½®ï¼ˆWGS84ï¼‰
                console.log('ç„¡æ¸¬è©¦åº§æ¨™ï¼Œå–å¾—ç•¶å‰ GPS ä½ç½®...');

                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            const lat = position.coords.latitude;
                            const lon = position.coords.longitude;
                            console.log('ç•¶å‰ GPS ä½ç½® (WGS84):', lat, lon);
                            performFacilityQuery(lat, lon, false, layerGroup, layerName, attributeName, facilityType);
                        },
                        (error) => {
                            console.error('ç„¡æ³•å–å¾— GPS ä½ç½®:', error);
                            snackbarText.value = 'ç„¡æ³•å–å¾—ä½ç½®è³‡è¨Š';
                            showSnackbar.value = true;
                            if (snackbarTimer) clearTimeout(snackbarTimer);
                            snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 2000);
                        }
                    );
                } else {
                    console.error('ç€è¦½å™¨ä¸æ”¯æ´ Geolocation');
                    snackbarText.value = 'ç€è¦½å™¨ä¸æ”¯æ´å®šä½åŠŸèƒ½';
                    showSnackbar.value = true;
                    if (snackbarTimer) clearTimeout(snackbarTimer);
                    snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 2000);
                }
            }
        };

        // åŸ·è¡Œè¨­æ–½æŸ¥è©¢
        const performFacilityQuery = async (coord1, coord2, isTWD97, layerGroup, layerName, attributeName, facilityType) => {
            console.log('åŸ·è¡Œè¨­æ–½æŸ¥è©¢:', { coord1, coord2, isTWD97, layerGroup, layerName, attributeName, facilityType });
            console.log('ç•¶å‰ layerList:', layerList);
            console.log('ç•¶å‰ appArea:', appArea);
            console.log('ç•¶å‰ baseUrl:', baseUrl);

            try {
                // å¾ layerList æ‰¾åˆ°å°æ‡‰çš„åœ–å±¤ç¾¤çµ„
                const targetLayer = layerList.find(l => l.name === layerGroup);
                console.log('æœå°‹åœ–å±¤ç¾¤çµ„:', layerGroup);
                console.log('æ‰¾åˆ°çš„åœ–å±¤:', targetLayer);

                if (!targetLayer || !targetLayer.url) {
                    console.error('layerList å…§å®¹:', layerList.map(l => ({ name: l.name, url: l.url })));
                    throw new Error(`æ‰¾ä¸åˆ°${layerGroup}åœ–å±¤`);
                }

                console.log('æ‰¾åˆ°åœ–å±¤ç¾¤çµ„:', layerGroup, 'URL:', targetLayer.url);

                // è¼‰å…¥åœ–å±¤ä»¥å–å¾— sublayers
                const tempLayer = new MapImageLayerClass({
                    url: targetLayer.url,
                    customParameters: { token: appToken }
                });

                console.log('é–‹å§‹è¼‰å…¥åœ–å±¤...');
                await tempLayer.load();
                console.log('åœ–å±¤å·²è¼‰å…¥ï¼Œsublayers æ•¸é‡:', tempLayer.sublayers?.length);

                // ä½¿ç”¨ findLayerUrl æ‰¾åˆ°ç›®æ¨™åœ–å±¤
                const targetLayerUrl = findLayerUrl(tempLayer, layerName);
                console.log('ä½¿ç”¨ findLayerUrl æœå°‹:', layerName);
                console.log('æ‰¾åˆ°çš„ URL:', targetLayerUrl);

                if (!targetLayerUrl) {
                    // åˆ—å‡ºæ‰€æœ‰å¯ç”¨çš„å­åœ–å±¤åç¨±
                    if (tempLayer.sublayers) {
                        console.error('å¯ç”¨çš„å­åœ–å±¤:', tempLayer.sublayers.map(sl => sl.title).join(', '));
                    }
                    throw new Error(`æ‰¾ä¸åˆ°${layerName}åœ–å±¤`);
                }

                console.log('ç›®æ¨™åœ–å±¤ URL:', targetLayerUrl);

                let pointTWD97;

                if (isTWD97) {
                    // æ¸¬è©¦åº§æ¨™å·²ç¶“æ˜¯ TWD97ï¼Œç›´æ¥ä½¿ç”¨
                    pointTWD97 = new PointClass({
                        x: coord1,
                        y: coord2,
                        spatialReference: { wkid: 3826 }
                    });
                    console.log('ä½¿ç”¨ TWD97 åº§æ¨™ (æ¸¬è©¦åº§æ¨™):', coord1, coord2);
                } else {
                    // GPS åº§æ¨™æ˜¯ WGS84ï¼Œéœ€è¦è½‰æ›
                    console.log('åŸå§‹åº§æ¨™ (WGS84):', coord1, coord2);

                    // è½‰æ›åº§æ¨™åˆ° TWD97
                    if (!projectionModule) {
                        throw new Error('æŠ•å½±æ¨¡çµ„æœªè¼‰å…¥');
                    }

                    await projectionModule.load();
                    console.log('æŠ•å½±æ¨¡çµ„å·²è¼‰å…¥');

                    // ä½¿ç”¨ PointClass å»ºç«‹é» (coord1=lat, coord2=lon)
                    const pointWGS84 = new PointClass({
                        longitude: coord2,
                        latitude: coord1,
                        spatialReference: { wkid: 4326 }
                    });

                    console.log('å»ºç«‹ WGS84 é»:', pointWGS84);

                    // è½‰æ›åº§æ¨™
                    pointTWD97 = projectionModule.project(pointWGS84, new SpatialReferenceClass({ wkid: 3826 }));

                    console.log('è½‰æ›çµæœ:', pointTWD97);

                    if (!pointTWD97 || pointTWD97.x === undefined || pointTWD97.y === undefined) {
                        throw new Error('åº§æ¨™è½‰æ›å¤±æ•—');
                    }

                    console.log('TWD97 åº§æ¨™:', pointTWD97.x, pointTWD97.y);
                }

                // å»ºç«‹ 50m ç·©è¡å€
                const bufferGeometry = geometryEngine.buffer(pointTWD97, 50, 'meters');
                console.log('ç·©è¡å€å·²å»ºç«‹: 50m');

                // æŸ¥è©¢åœ–å±¤
                const featureLayer = new FeatureLayerClass({
                    url: targetLayerUrl,
                    customParameters: { token: appToken }
                });

                await featureLayer.load();
                console.log('FeatureLayer è¼‰å…¥æˆåŠŸ');

                const query = featureLayer.createQuery();
                query.geometry = bufferGeometry;
                query.spatialRelationship = 'intersects';
                query.returnGeometry = false;
                query.outFields = ['*'];  // å…ˆå–å¾—æ‰€æœ‰æ¬„ä½

                console.log('æº–å‚™æŸ¥è©¢ï¼Œéœ€è¦çš„å±¬æ€§:', attributeName);
                console.log('æŸ¥è©¢è¨­å®š:', {
                    spatialRelationship: query.spatialRelationship,
                    outFields: query.outFields,
                    returnGeometry: query.returnGeometry
                });

                const result = await featureLayer.queryFeatures(query);
                console.log('æŸ¥è©¢å®Œæˆï¼Œæ‰¾åˆ°:', result.features.length, 'å€‹è¨­æ–½');

                if (result.features.length === 0) {
                    snackbarText.value = 'é™„è¿‘ 50m å…§ç„¡è¨­æ–½';
                    showSnackbar.value = true;
                    if (snackbarTimer) clearTimeout(snackbarTimer);
                    snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 2000);
                    return;
                }

                // è™•ç†æŸ¥è©¢çµæœ
                processImprovementResults(result.features, attributeName, facilityType);

            } catch (error) {
                console.error('æŸ¥è©¢è¨­æ–½å¤±æ•— - éŒ¯èª¤é¡å‹:', typeof error);
                console.error('æŸ¥è©¢è¨­æ–½å¤±æ•— - éŒ¯èª¤è¨Šæ¯:', error.message || error.toString());
                console.error('æŸ¥è©¢è¨­æ–½å¤±æ•— - éŒ¯èª¤ç‰©ä»¶:', JSON.stringify(error, Object.getOwnPropertyNames(error)));
                console.error('æŸ¥è©¢è¨­æ–½å¤±æ•— - éŒ¯èª¤å †ç–Š:', error.stack);

                let errorMsg = 'æŸ¥è©¢è¨­æ–½å¤±æ•—';
                if (error.message) {
                    errorMsg += ': ' + error.message;
                } else if (error.toString) {
                    errorMsg += ': ' + error.toString();
                }

                snackbarText.value = errorMsg;
                showSnackbar.value = true;
                if (snackbarTimer) clearTimeout(snackbarTimer);
                snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 3000);
            }
        };

        // è™•ç†æ”¹å–„å›å ±æŸ¥è©¢çµæœ
        const processImprovementResults = (features, attributeName, facilityType) => {
            console.log('è™•ç†æ”¹å–„å›å ±æŸ¥è©¢çµæœ:', features.length, 'ç­†');
            console.log('éœ€è¦çš„å±¬æ€§åç¨±:', attributeName);
            console.log('è¨­æ–½é¡å‹:', facilityType);

            // æŸ¥çœ‹ç¬¬ä¸€ç­†è³‡æ–™çš„æ‰€æœ‰å±¬æ€§
            if (features.length > 0) {
                console.log('ç¬¬ä¸€ç­†è³‡æ–™çš„æ‰€æœ‰å±¬æ€§:', Object.keys(features[0].attributes));
                console.log('ç¬¬ä¸€ç­†å®Œæ•´è³‡æ–™:', features[0].attributes);
            }

            // é€šç”¨å±¬æ€§æå–å‡½æ•¸
            const getAttributeValue = (attrs, attrName) => {
                // å˜—è©¦å„ç¨®å¤§å°å¯«çµ„åˆ
                const variations = [
                    attrName,                           // åŸå§‹
                    attrName.toUpperCase(),             // å…¨å¤§å¯«
                    attrName.toLowerCase(),             // å…¨å°å¯«
                    attrName.charAt(0).toUpperCase() + attrName.slice(1).toLowerCase() // é¦–å­—æ¯å¤§å¯«
                ];

                for (let variation of variations) {
                    if (attrs[variation] !== undefined && attrs[variation] !== null) {
                        return attrs[variation];
                    }
                }
                return null;
            };

            let resultList = [];

            if (facilityType === 'aerial') {
                // æ¶ç©ºï¼šä½¿ç”¨ FULLNO_
                resultList = features.map(f => {
                    const fullno = getAttributeValue(f.attributes, 'FULLNO_');
                    console.log('æ¶ç©ºè¨­æ–½ FULLNO_:', fullno);
                    return fullno;
                }).filter(v => v);
            } else if (facilityType === 'terminal') {
                // äº¤æ¥ç®±ï¼šCENTOFF+ACCNO
                resultList = features.map(f => {
                    const centoff = getAttributeValue(f.attributes, 'CENTOFF') || '';
                    const accno = getAttributeValue(f.attributes, 'ACCNO') || '';
                    console.log('äº¤æ¥ç®± CENTOFF:', centoff, 'ACCNO:', accno);
                    return centoff + accno;
                }).filter(v => v);
            } else {
                // äººå­”/æ‰‹å­”ï¼šä½¿ç”¨ FULLNO_
                resultList = features.map(f => {
                    const fullno = getAttributeValue(f.attributes, 'FULLNO_');
                    console.log('åœ°ä¸‹è¨­æ–½ FULLNO_:', fullno);
                    return fullno;
                }).filter(v => v);
            }

            console.log('è¨­æ–½æ¸…å–®:', resultList);
            console.log('è¨­æ–½æ•¸é‡:', resultList.length);

            // çµ„æˆå­—ä¸²ï¼Œç”¨é€—è™Ÿåˆ†éš”
            const listString = resultList.join(',');
            console.log('è¨­æ–½å­—ä¸² (clslist/glist):', listString);

            // å‚³çµ¦ Android
            if (window.Android && window.Android.openImprovementReport) {
                const paramName = facilityType === 'aerial' ? 'clslist' : 'glist';
                console.log('å‘¼å« Android.openImprovementReport, åƒæ•¸:', paramName, '=', listString);
                window.Android.openImprovementReport(paramName, listString);
            } else {
                console.log('Android.openImprovementReport ä¸å¯ç”¨');
                console.log('è¨­æ–½æ¸…å–® (' + (facilityType === 'aerial' ? 'clslist' : 'glist') + '):', listString);

                // é¡¯ç¤ºçµæœ
                snackbarText.value = 'æ‰¾åˆ° ' + resultList.length + ' å€‹è¨­æ–½: ' + listString;
                showSnackbar.value = true;
                if (snackbarTimer) clearTimeout(snackbarTimer);
                snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 5000);
            }
        };

        // é—œé–‰å°è©±æ¡†
        window.closeImprovementTypeDialog = () => {
            const dialog = document.getElementById('improvementTypeDialog');
            const mask = document.getElementById('improvementTypeMask');
            if (dialog) dialog.parentElement.remove();
            if (mask) mask.remove();
        };

        window.closeUndergroundFacilityDialog = () => {
            const dialog = document.getElementById('undergroundFacilityDialog');
            const mask = document.getElementById('undergroundFacilityMask');
            if (dialog) dialog.parentElement.remove();
            if (mask) mask.remove();
        };

        const onSubMenuItemClick = (item) => {
            console.log("Selected:", item);

            // è™•ç†åº§æ¨™æŸ¥è©¢
            if (item === "åº§æ¨™æŸ¥è©¢") {
                closeAll();
                openCoordinateDialog();
                return;
            }

            // è™•ç†å°èˆªç›®æ¨™
            if (item === "å°èˆªç›®æ¨™") {
                closeAll();
                openNavigationDialog();
                return;
            }

            // è™•ç†é‡æ¸¬ç¹ªåœ–
            if (item === "é‡æ¸¬ç¹ªåœ–") {
                closeAll();
                openDrawToolbar();
                return;
            }

            // è™•ç†æŠ“åœ°åœ–ç•«é¢
            if (item === "æŠ“åœ°åœ–ç•«é¢") {
                closeAll();
                captureMapScreen();
                return;
            }

            // è™•ç†æ‹ç…§åŠ è¨»æ–‡å­—èˆ‡åº§æ¨™
            if (item === "æ‹ç…§åŠ è¨»æ–‡å­—èˆ‡åº§æ¨™") {
                closeAll();
                openPhotoDialog();
                return;
            }

            // è™•ç†å·¡å‹˜æ”¹å–„è¨­è¨ˆåœ–
            if (item === "å·¡å‹˜æ”¹å–„è¨­è¨ˆåœ–") {
                closeAll();
                openAnnotationToolbar();
                return;
            }

            // è™•ç†é“è·¯å·¡å‹˜ç‹€æ…‹æŸ¥è©¢ï¼ˆå·¡å‹˜åŠŸèƒ½ï¼‰
            if (item === "é“è·¯å·¡å‹˜ç‹€æ…‹æŸ¥è©¢" || item === "å·¡å‹˜åŠŸèƒ½") {
                closeAll();
                startInspection();
                return;
            }

            // è™•ç†è»Œè·¡å·¡å‹˜
            if (item === "è»Œè·¡å·¡å‹˜") {
                closeAll();
                startTrackInspection();
                return;
            }

            // è™•ç†ä¸Šæ¬¡è»Œè·¡é‡é€
            if (item === "ä¸Šæ¬¡è»Œè·¡é‡é€") {
                closeAll();
                resendLastTrack();
                return;
            }

            // è™•ç†è·¨è¶Šçºœç·šè³‡æ–™å»ºç«‹
            if (item === "è·¨è¶Šçºœç·šè³‡æ–™å»ºç«‹") {
                closeAll();
                startCableCrossing();
                return;
            }

            // è™•ç†å·¡å‹˜æ”¹å–„å›å ±
            if (item === "å·¡å‹˜æ”¹å–„å›å ±") {
                closeAll();
                startImprovementReport();
                return;
            }

            // è™•ç†åˆ‡æ›äººå“¡
            if (item === "åˆ‡æ›äººå“¡") {
                closeAll();
                if (window.Android && window.Android.switchUser) {
                    window.Android.switchUser();
                } else {
                    console.log("Android.switchUser not available");
                    snackbarText.value = "åˆ‡æ›äººå“¡åŠŸèƒ½ä¸å¯ç”¨";
                    showSnackbar.value = true;
                    if (snackbarTimer) clearTimeout(snackbarTimer);
                    snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 2000);
                }
                return;
            }

            // è™•ç†æ¸…é™¤ç•«é¢ç¹ªåœ–
            if (item === "æ¸…é™¤ç•«é¢ç¹ªåœ–") {
                closeAll();
                clearAllGraphics();
                return;
            }

            // è™•ç†ä»Šæ—¥æ–½å·¥ä½ç½®ï¼ˆå°åŒ—å¸‚/æ–°åŒ—å¸‚/æ¡ƒåœ’å¸‚ï¼‰
            if (item === "å°åŒ—å¸‚ä»Šæ—¥æ–½å·¥ä½ç½®" || item === "æ–°åŒ—å¸‚ä»Šæ—¥æ–½å·¥ä½ç½®" || item === "æ¡ƒåœ’å¸‚ä»Šæ—¥æ–½å·¥ä½ç½®") {
                closeAll();

                if (item === "å°åŒ—å¸‚ä»Šæ—¥æ–½å·¥ä½ç½®") {
                    // å¾ Android å–å¾— TPG41 åœ–å±¤ URL
                    if (window.Android && window.Android.getLayerUrl) {
                        const pipeUrl = window.Android.getLayerUrl('TPG41');
                        console.log('å–å¾—å¹¹ç·šç®¡é“ URL:', pipeUrl);

                        if (window.TaipeiConstructionModule) {
                            // è¨­å®šåœ–å±¤ URL å¾Œè¼‰å…¥è³‡æ–™
                            TaipeiConstructionModule.setPipeLayerUrl(pipeUrl);
                            TaipeiConstructionModule.loadConstructionData();
                        } else {
                            console.error('TaipeiConstructionModule æœªè¼‰å…¥');
                            showInspectionMessage('å°åŒ—å¸‚æ–½å·¥ä½ç½®æ¨¡çµ„æœªè¼‰å…¥');
                        }
                    } else {
                        console.error('Android.getLayerUrl ä¸å¯ç”¨');
                        showInspectionMessage('ç„¡æ³•å–å¾—åœ–å±¤è³‡è¨Š');
                    }
                } else if (item === "æ–°åŒ—å¸‚ä»Šæ—¥æ–½å·¥ä½ç½®") {
                    if (window.NewTaipeiConstructionModule) {
                        NewTaipeiConstructionModule.loadConstructionData();
                    } else {
                        console.error('NewTaipeiConstructionModule æœªè¼‰å…¥');
                        showInspectionMessage('æ–°åŒ—å¸‚æ–½å·¥ä½ç½®æ¨¡çµ„æœªè¼‰å…¥');
                    }
                } else if (item === "æ¡ƒåœ’å¸‚ä»Šæ—¥æ–½å·¥ä½ç½®") {
    // å¾ Android å–å¾— TYG41 åœ–å±¤ URLï¼ˆæ¡ƒåœ’å¹¹ç·šç®¡é“ï¼‰
    if (window.Android && window.Android.getLayerUrl) {
        const pipeUrl = window.Android.getLayerUrl('TYG41');
        console.log('å–å¾—æ¡ƒåœ’å¹¹ç·šç®¡é“ URL:', pipeUrl);

        if (window.TaoyuanConstructionModule) {
            // è¨­å®šåœ–å±¤ URL å¾Œè¼‰å…¥è³‡æ–™
            TaoyuanConstructionModule.setPipeLayerUrl(pipeUrl);
            TaoyuanConstructionModule.loadConstructionData();
        } else {
            console.error('TaoyuanConstructionModule æœªè¼‰å…¥');
            showInspectionMessage('æ¡ƒåœ’å¸‚æ–½å·¥ä½ç½®æ¨¡çµ„æœªè¼‰å…¥');
        }
    } else {
        console.error('Android.getLayerUrl ä¸å¯ç”¨');
        showInspectionMessage('ç„¡æ³•å–å¾—åœ–å±¤è³‡è¨Š');
    }
}

                return;
            }

            // è™•ç†ç™»å‡º
            if (item === "ç™»å‡º") {
                closeAll();
                if (window.Android && window.Android.logout) {
                    window.Android.logout();
                } else {
                    console.log("Android.logout not available");
                    snackbarText.value = "ç™»å‡ºåŠŸèƒ½ä¸å¯ç”¨";
                    showSnackbar.value = true;
                    if (snackbarTimer) clearTimeout(snackbarTimer);
                    snackbarTimer = setTimeout(() => { showSnackbar.value = false; }, 2000);
                }
                return;
            }

            // æª¢æŸ¥æ˜¯å¦ç‚ºå·²é…ç½®çš„æŸ¥è©¢é¡å‹
            if (queryConfigs[item]) {
                closeAll();
                openQueryDialog(item);
                return;
            }

            if (window.Android && window.Android.showToast) {
                window.Android.showToast("é¸æ“‡äº†: " + item);
            }
            closeAll();
        };

        const toggleMapLayer = (layerInfo) => {
            let tokenPart = appToken ? "?token=" + appToken : "";
            console.log("Toggle Layer: " + layerInfo.name + ", URL: " + layerInfo.url + tokenPart + ", Enabled: " + layerInfo.isEnabled);

            if (!map || !MapImageLayerClass) return;

            if (layerInfo.isEnabled) {
                if (!layerInfo.layerObj) {
                    const newLayer = new MapImageLayerClass({
                        url: layerInfo.url,
                        customParameters: { token: appToken }
                    });

                    newLayer.on("error", (e) => {
                        console.error("Layer load error:", e);
                        if (window.Android && window.Android.showToast) {
                            window.Android.showToast("åœ–å±¤è¼‰å…¥å¤±æ•—: " + layerInfo.name);
                        }
                    });

                    layerInfo.layerObj = markRaw(newLayer);
                }

                if (!map.layers.includes(layerInfo.layerObj)) {
                    map.add(layerInfo.layerObj);
                }
            } else {
                if (layerInfo.layerObj) {
                    map.remove(layerInfo.layerObj);
                }
            }
        };

        // ===== è·¨è¶Šçºœç·šå‡½æ•¸ =====

        /**
         * é–‹å§‹è·¨è¶Šçºœç·šåŠŸèƒ½
         */
        const startCableCrossing = async () => {
            console.log('é–‹å§‹è·¨è¶Šçºœç·šè³‡æ–™å»ºç«‹');

            if (!window.CableCrossingModule) {
                console.error('CableCrossingModule æœªå°±ç·’');
                showInspectionMessage('è·¨è¶Šçºœç·šæ¨¡çµ„æœªå°±ç·’');
                return;
            }

            if (!ldap.value) {
                console.error('LDAP æœªå–å¾—');
                showInspectionMessage('ç„¡æ³•å–å¾—ä½¿ç”¨è€…è³‡è¨Š');
                return;
            }

            try {
                await CableCrossingModule.start(layerList, ldap.value);
            } catch (error) {
                console.error('å•Ÿå‹•è·¨è¶Šçºœç·šå¤±æ•—:', error);
                showInspectionMessage('å•Ÿå‹•å¤±æ•—: ' + error.message);
            }
        };

        /**
         * é¡¯ç¤ºé›»æ¡¿æ¸…å–®
         */
        const showPoleList = (poles) => {
            console.log('é¡¯ç¤ºé›»æ¡¿æ¸…å–®ï¼Œå…±', poles.length, 'å€‹');
            nearbyPoles.value = poles;
            poleListVisible.value = true;
        };

        /**
         * é—œé–‰é›»æ¡¿æ¸…å–®
         */
        const closePoleList = () => {
            poleListVisible.value = false;
        };

        /**
         * é¸æ“‡é›»æ¡¿
         */
        const onPoleSelected = async (pole) => {
            console.log('é¸æ“‡é›»æ¡¿:', pole.displayName);

            // Zoom åˆ°é›»æ¡¿
            await CableCrossingModule.selectPole(pole);

            // é—œé–‰æ¸…å–®
            closePoleList();

            // é¡¯ç¤ºç¢ºèªå°è©±æ¡†
            const confirmed = confirm(`ç¢ºèªé¸æ“‡æ­¤é›»æ¡¿ï¼Ÿ\n${pole.displayName}`);

            if (confirmed) {
                // æŸ¥è©¢é›»æ¡¿è³‡è¨Š
                showInspectionMessage('æŸ¥è©¢é›»æ¡¿è³‡è¨Š...');
                await CableCrossingModule.getPoleInfo(pole.fullNo, ldap.value);
            }
        };

        /**
         * é›»æ¡¿è³‡è¨Šæ¥æ”¶å®Œæˆ
         */
        const onPolesInfoReceived = (data) => {
            console.log('é›»æ¡¿è³‡è¨Šæ¥æ”¶å®Œæˆ');
            console.log('æ”¶åˆ°çš„è³‡æ–™:', data);

            // å„²å­˜æ¥­è€…æ¸…å–®
            vendersList.value = data.venders || [];
            console.log('æ¥­è€…æ¸…å–®:', vendersList.value.length, 'å€‹');

            // å–å¾—é›»æ¡¿è³‡è¨Šï¼ˆè™•ç†é™£åˆ—æˆ–ç‰©ä»¶æ ¼å¼ï¼‰
            let poleInfo = null;
            if (data.poles) {
                if (Array.isArray(data.poles)) {
                    poleInfo = data.poles.length > 0 ? data.poles[0] : null;
                } else {
                    poleInfo = data.poles;
                }
            }

            if (!poleInfo) {
                console.error('âŒ ç„¡æ³•å–å¾—é›»æ¡¿è³‡è¨Š');
                showInspectionMessage('ç„¡æ³•å–å¾—é›»æ¡¿è³‡è¨Š');
                return;
            }

            console.log('âœ“ é›»æ¡¿è³‡è¨Š:', poleInfo.fullNo);
            console.log('âœ“ ç›¸é„°é›»æ¡¿æ•¸é‡:', poleInfo.poleNeighbors?.length || 0);

            // å–å¾—ç›¸é„°é›»æ¡¿è³‡è¨Šï¼ˆç¬¬ä¸€å€‹ï¼‰
            const neighbor = poleInfo.poleNeighbors && poleInfo.poleNeighbors.length > 0
                ? poleInfo.poleNeighbors[0]
                : null;

            if (neighbor) {
                console.log('âœ“ ä½¿ç”¨ç¬¬ä¸€å€‹ç›¸é„°é›»æ¡¿:', neighbor.fullNo);
            } else {
                console.log('âš  æ²’æœ‰ç›¸é„°é›»æ¡¿è³‡æ–™');
            }

            // å¡«å…¥è¡¨å–®é è¨­å€¼
            cableFormData.value.mainPole = poleInfo.fullNo;
            cableFormData.value.acrossroadtype = neighbor?.acrossroadtype || 'N';
            cableFormData.value.neighborFullNo = neighbor?.fullNo || '';
            cableFormData.value.roadwidth = neighbor?.roadwidth || 3;
            cableFormData.value.note = neighbor?.note || '';
            cableFormData.value.photoBase64 = null;

            // é™„æ›çºœç·š
            if (neighbor && neighbor.poleLines && neighbor.poleLines.length > 0) {
                console.log('âœ“ é™„æ›çºœç·š:', neighbor.poleLines.length, 'æ¢');
                cableFormData.value.poleLines = neighbor.poleLines.map(line => {
                    // æŸ¥æ‰¾æ¥­è€…åç¨±
                    const vender = vendersList.value.find(v =>
                        v.vendertype === line.vendertype && v.vendersn === line.vendersn
                    );

                    // åˆ¤æ–·æ˜¯å¦ç§Ÿç”¨ï¼š'1' æˆ– 'Y' ç‚ºç§Ÿç”¨
                    const isRent = line.isrent === '1' || line.isrent === 'Y';

                    return {
                        vendertype: line.vendertype,
                        vendersn: line.vendersn,
                        vendername: vender?.vendername || '',
                        linenum: line.linenum || 0,
                        height: line.height || 0,
                        isRentChecked: isRent,
                        isrent: line.isrent,
                        leasedate: line.leasedate ? line.leasedate.split('T')[0] : ''
                    };
                });
            } else {
                console.log('âš  æ²’æœ‰é™„æ›çºœç·šè³‡æ–™');
                cableFormData.value.poleLines = [];
            }

            console.log('âœ“ è¡¨å–®è³‡æ–™å·²å¡«å…¥ï¼Œæº–å‚™é¡¯ç¤º');

            // é¡¯ç¤ºè¡¨å–®
            cableFormVisible.value = true;
        };

        /**
         * é—œé–‰çºœç·šè¡¨å–®
         */
        const closeCableForm = () => {
            cableFormVisible.value = false;
        };

        /**
         * æ–°å¢é™„æ›çºœç·š
         */
        const addPoleLine = () => {
            cableFormData.value.poleLines.push({
                vendertype: '',
                vendersn: '',
                vendername: '',
                linenum: 0,
                height: 0,
                isRentChecked: false,
                isrent: '0',
                leasedate: ''
            });
        };

        /**
         * åˆªé™¤é™„æ›çºœç·š
         */
        const removePoleLine = (index) => {
            if (confirm('ç¢ºå®šè¦åˆªé™¤æ­¤é™„æ›çºœç·šï¼Ÿ')) {
                cableFormData.value.poleLines.splice(index, 1);
            }
        };

        /**
         * æ¥­è€…é¸æ“‡æ”¹è®Šï¼ˆç´šè¯å¡«å…¥ï¼‰
         */
        const onVenderChange = (index) => {
            const line = cableFormData.value.poleLines[index];
            const vender = vendersList.value.find(v => v.vendername === line.vendername);

            if (vender) {
                line.vendertype = vender.vendertype;
                line.vendersn = vender.vendersn;
            }
        };

        /**
         * ç§Ÿç”¨é¸é …æ”¹è®Š
         */
        const onRentChange = (index) => {
            const line = cableFormData.value.poleLines[index];
            line.isrent = line.isRentChecked ? '1' : '0';

            if (!line.isRentChecked) {
                line.leasedate = '';
            }
        };

        /**
         * é¸æ“‡ç…§ç‰‡
         */
        const selectPhoto = () => {
            console.log('é¸æ“‡ç…§ç‰‡');

            if (window.Android && window.Android.selectPhoto) {
                window.Android.selectPhoto();
            } else {
                console.error('Android.selectPhoto not available');
                showInspectionMessage('ç„¡æ³•é¸æ“‡ç…§ç‰‡');
            }
        };

        /**
         * æ‹ç…§
         */
        const takePhoto = () => {
            console.log('æ‹ç…§');

            if (window.Android && window.Android.takePhoto) {
                window.Android.takePhoto();
            } else {
                console.error('Android.takePhoto not available');
                showInspectionMessage('ç„¡æ³•æ‹ç…§');
            }
        };

        /**
         * ç§»é™¤ç…§ç‰‡
         */
        const removePhoto = () => {
            cableFormData.value.photoBase64 = null;
        };

        /**
         * ç…§ç‰‡é¸æ“‡å®Œæˆï¼ˆç”± Android å‘¼å«ï¼‰
         */
        const onPhotoSelected = (base64) => {
            console.log('ç…§ç‰‡é¸æ“‡å®Œæˆï¼ŒBase64 é•·åº¦:', base64.length);
            cableFormData.value.photoBase64 = base64;
            showInspectionMessage('ç…§ç‰‡å·²é¸æ“‡');
        };

        /**
         * é©—è­‰è¡¨å–®
         */
        const validateCableForm = () => {
            const data = cableFormData.value;

            // 1. ä»–ç«¯é™„æ›é»
            if (!data.neighborFullNo) {
                showInspectionMessage('è«‹é¸æ“‡ä»–ç«¯é™„æ›é»');
                return false;
            }

            if (data.neighborFullNo === data.mainPole) {
                showInspectionMessage('ä»–ç«¯é™„æ›é»ä¸å¯ä»¥æ˜¯ä¸»å¹¹æœ¬èº«');
                return false;
            }

            // 2. é“è·¯å¯¬åº¦
            if (data.roadwidth < 3 || data.roadwidth > 50) {
                showInspectionMessage('é“è·¯å¯¬åº¦å¿…é ˆåœ¨ 3-50 å…¬å°ºä¹‹é–“');
                return false;
            }

            // 3. é™„æ›çºœç·šé©—è­‰
            for (let i = 0; i < data.poleLines.length; i++) {
                const line = data.poleLines[i];

                if (!line.vendername) {
                    showInspectionMessage(`ç¬¬ ${i+1} æ¢çºœç·šï¼šè«‹é¸æ“‡æ¥­è€…`);
                    return false;
                }

                if (!line.linenum || line.linenum <= 0) {
                    showInspectionMessage(`ç¬¬ ${i+1} æ¢çºœç·šï¼šé™„æ›æ•¸é‡å¿…é ˆå¤§æ–¼ 0`);
                    return false;
                }

                if (!line.height || line.height <= 0) {
                    showInspectionMessage(`ç¬¬ ${i+1} æ¢çºœç·šï¼šçºœç·šé«˜åº¦å¿…é ˆå¤§æ–¼ 0`);
                    return false;
                }

                if (line.isRentChecked && !line.leasedate) {
                    showInspectionMessage(`ç¬¬ ${i+1} æ¢çºœç·šï¼šè«‹é¸æ“‡ç§Ÿç”¨æ—¥æœŸ`);
                    return false;
                }
            }

            return true;
        };

        /**
         * é€å‡ºçºœç·šè³‡æ–™
         */
        const submitCableData = () => {
            console.log('æº–å‚™é€å‡ºçºœç·šè³‡æ–™');

            // é©—è­‰è¡¨å–®
            if (!validateCableForm()) {
                return;
            }

            // çµ„è£é€å‡ºè³‡æ–™
            const formData = {
                mainPole: cableFormData.value.mainPole,
                acrossroadtype: cableFormData.value.acrossroadtype,
                neighborFullNo: cableFormData.value.neighborFullNo,
                roadwidth: cableFormData.value.roadwidth,
                note: cableFormData.value.note,
                photoBase64: cableFormData.value.photoBase64,
                poleLines: cableFormData.value.poleLines.map(line => {
                    const poleLine = {
                        vendertype: line.vendertype,
                        vendersn: line.vendersn,
                        vendername: line.vendername,
                        linenum: line.linenum,
                        height: line.height,
                        isrent: line.isRentChecked ? '1' : '0'
                    };

                    // åªæœ‰ç§Ÿç”¨æ™‚æ‰åŒ…å«ç§Ÿç”¨æ—¥æœŸï¼ˆISO 8601 æ ¼å¼ï¼‰
                    if (line.isRentChecked && line.leasedate) {
                        poleLine.leasedate = new Date(line.leasedate).toISOString();
                    } else {
                        poleLine.leasedate = '';
                    }

                    return poleLine;
                })
            };

            console.log('çµ„è£å®Œæˆçš„è¡¨å–®è³‡æ–™:', formData);

            // å‘¼å«æ¨¡çµ„é€å‡º
            const success = CableCrossingModule.submitCableData(formData, ldap.value);

            if (success) {
                showInspectionMessage('è³‡æ–™å·²é€å‡ºï¼Œç­‰å¾…å›æ‡‰...');
            }
        };

        /**
         * é€å‡ºæˆåŠŸ
         */
        const onCableSubmitSuccess = () => {
            console.log('è·¨è¶Šçºœç·šè³‡æ–™é€å‡ºæˆåŠŸ');

            // é—œé–‰è¡¨å–®
            closeCableForm();

            // æ¸…ç©ºè³‡æ–™
            cableFormData.value = {
                mainPole: '',
                acrossroadtype: 'N',
                neighborFullNo: '',
                roadwidth: 3,
                note: '',
                photoBase64: null,
                poleLines: []
            };

            showInspectionMessage('è·¨è¶Šçºœç·šè³‡æ–™é€å‡ºæˆåŠŸ');
        };

        return {
          isMainMenuVisible,
          currentSubMenu,
          isLayerDialogVisible,
          subMenuItems,
          layerList,
          selectedBasemap,
          isLocating,
          isLocationActive,
          toggleMainMenu,
          openSubMenu,
          openLayerDialog,
          closeAll,
          onSubMenuItemClick,
          toggleMapLayer,
          changeBasemap,
          triggerLocate,
          showSnackbar,
          snackbarText,
          isQueryDialogVisible,
          isResultListVisible,
          currentQueryType,
          queryParams,
          queryResults,
          queryConfigs,
          upperCaseInput,
          closeQueryDialog,
          executeQuery,
          closeResultList,
          zoomToResult,
          isCoordinateDialogVisible,
          coordinateParams,
          openCoordinateDialog,
          closeCoordinateDialog,
          executeCoordinateQuery,
          isDistrictListVisible,
          districtList,
          currentCity,
          selectConstructionDistrict,
          navigationTargets,
          isNavigationDialogVisible,
          openNavigationDialog,
          closeNavigationDialog,
          navigateToTarget,
          isDrawToolbarVisible,
          currentDrawTool,
          selectDrawTool,
          undoDrawing,
          redoDrawing,
          clearDrawing,
          exportDrawing,
          closeDrawToolbar,
          isPhotoDialogVisible,
          photoNote,
          photoCoordType,
          openPhotoDialog,
          closePhotoDialog,
          openCamera,
          isAnnotationToolbarVisible,
          currentAnnotationTool,
          isTextInputDialogVisible,
          annotationText,
          openAnnotationToolbar,
          selectAnnotationTool,
          closeTextInputDialog,
          confirmTextInput,
          undoAnnotation,
          redoAnnotation,
          clearAnnotation,
          addQRCode,
          exportAnnotation,
          closeAnnotationToolbar,
          isWorkTextDialogVisible,
          workText,
          openWorkTextDialog,
          closeWorkTextDialog,
          confirmWorkText,
          inspectionListVisible,
          inspectionListTitle,
          inspectionListItems,
          closeInspectionList,
          selectInspectionItem,
          startInspection,
          isTracking,
          trackStatus,
          trackConfirmVisible,
          trackDeviceCounts,
          trackDeviceList,
          trackScreenshot,
          startTrackInspection,
          stopTrackInspection,
          confirmTrackSend,
          cancelTrackConfirm,
          resendLastTrack,
          ldap,
          poleListVisible,
          cableFormVisible,
          nearbyPoles,
          vendersList,
          cableFormData,
          startCableCrossing,
          closePoleList,
          onPoleSelected,
          closeCableForm,
          addPoleLine,
          removePoleLine,
          onVenderChange,
          onRentChange,
          selectPhoto,
          takePhoto,
          removePhoto,
          submitCableData
        };
      }
    }).mount('#app');
</script>
</body>
</html>